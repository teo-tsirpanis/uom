# Λογικός Προγραμματισμός με Περιορισμούς - Εργασία 2

### Τσιρπάνης Θεόδωρος, `dai19090`

## Άσκηση 1

```prolog
% Exercise 1 code here
```

### Εκτέλεση

```
?- select_providers(X, Y, Price).
X = 3
Y = 4
Price = 58
Yes (0.00s cpu)
```

Η βέλτιστη λύση είναι μοναδική.

### Παρατηρήσεις

Το κατηγόρημα `Prov1 #< Prov2` χρησιμοποιήθηκε για να απαλείψει ισοδύναμες λύσεις όπου οι πάροχοι ήταν οι ίδιοι αλλά με διαφορετική σειρά. Χωρίς αυτό, θα υπήρχε και δεύτερη "λύση" με τιμές `X = 4, Y = 3`.

## Άσκηση 2

```prolog
% Exercise 2 code here
```

### Εκτέλεση

```
?- lectures(Classes, Starts, Makespan).
Classes = [clp, procedural, analysis, computer_sys, algebra]
Starts = [12, 9, 13, 9, 15]
Makespan = 18
Yes (0.00s cpu, solution 1, maybe more)
Classes = [clp, procedural, analysis, computer_sys, algebra]
Starts = [12, 9, 14, 9, 15]
Makespan = 18
Yes (0.00s cpu, solution 2, maybe more)
Classes = [clp, procedural, analysis, computer_sys, algebra]
Starts = [12, 9, 14, 10, 15]
Makespan = 18
Yes (0.00s cpu, solution 3, maybe more)
Classes = [clp, procedural, analysis, computer_sys, algebra]
Starts = [12, 15, 9, 13, 9]
Makespan = 18
Yes (0.00s cpu, solution 4, maybe more)
Classes = [clp, procedural, analysis, computer_sys, algebra]
Starts = [12, 15, 9, 14, 9]
Makespan = 18
Yes (0.00s cpu, solution 5, maybe more)
Classes = [clp, procedural, analysis, computer_sys, algebra]
Starts = [12, 15, 10, 14, 9]
Makespan = 18
Yes (0.00s cpu, solution 6, maybe more)
No (0.00s cpu)
```

Υπάρχουν έξι βέλτιστες λύσεις.

### Παρατηρήσεις

Χρησιμοποιείται δύο φορές ο περιορισμός `cumulative` για να δηλώσει τους διαθέσιμους καθηγητές, καθώς και τις άδειες του Zoom.

Το παράδειγμα εκτέλεσης της εκφώνησης θα μπορούσε να παραπλανήσει τον αναγνώστη της, κάνοντάς τον να πιστεύει ότι τα ονόματα των μαθημάτων θα πρέπει να είναι με τη σειρά που ξεκινάνε, αλλά κάτι τέτοιο δεν απαιτείται ρητά (και η υλοποίησή του θα ήταν σημαντικά δυσκολότερη)· τα ονόματα χρησιμοποιούνται αποκλειστικά για ευκολία ανάγνωσης της λύσης και συλλέγονται ήδη από την πρώτη γραμμή του κύριου κατηγορήματος.

## Άσκηση 3

```prolog
% Exercise 3 code here
```

### Εκτέλεση

```
?- company(S, D, Machines, M).
S = st([0, 0, 29, 25])
D = dur([10, 14, 12, 16])
Machines = machines([4, 4, 4, 4])
M = 56
Yes (0.91s cpu, solution 1, maybe more)
S = st([0, 27, 0, 25])
D = dur([10, 14, 12, 16])
Machines = machines([4, 4, 4, 4])
M = 56
Yes (0.98s cpu, solution 2, maybe more)
S = st([31, 0, 29, 0])
D = dur([10, 14, 12, 16])
Machines = machines([4, 4, 4, 4])
M = 56
Yes (1.89s cpu, solution 3, maybe more)
S = st([31, 27, 0, 0])
D = dur([10, 14, 12, 16])
Machines = machines([4, 4, 4, 4])
M = 56
Yes (1.95s cpu, solution 4, maybe more)
No (2.11s cpu)
```

Υπάρχουν τέσσερεις βέλτιστες λύσεις.

### Παρατηρήσεις

Όπως και πριν, η μεγαλύτερη πρόκληση της άσκησης ήταν η προσεκτική κατανόηση της εκφώνησης. Η ύπαρξη του ποιοτικού ελέγχου σημαίνει ουσιαστικά ότι μόνο δύο παραγγελίες μπορούν να διεκπεραιωθούν ταυτόχρονα. Για τον περιορισμό αυτόν, καθώς και τον περιορισμό των μηχανών, χρησιμοποιήθηκε ξανά δύο φορές ο περιορισμός `cumulative`.

Υπάρχουν δύο λίστες που κρατούν διάρκεια· η πρώτη κρατάει τη διάρκεια μόνο της εκτύπωσης και "επιστρέφεται" στο κατηγόρημα, ενώ η δεύτερη κρατάει τη συνολική διάρκεια προετοιμασίας και εκτύπωσης και χρησιμοποιείται στον χρονοπρογραμματισμό των παραγγελιών και των μηχανών.

Στην τιμή του `M` αφαιρούνται δεκαπέντε λεπτά από τον μέγιστο χρόνο τερματισμού, επειδή υποθέτουμε ότι οι μηχανές έχουν ήδη αρχικοποιηθεί, σύμφωνα με διευκρίνηση σε συνάδελφο, και για να εμφανίζει σωστές τιμές το πρόγραμμα σύμφωνα με το παράδειγμα, κάτι που μπορεί να επαληθευτεί αν το ερώτημα `company(st([0, 0, 23, 43]), _, machines([5, 2, 2, 2]), 75)` πετυχαίνει.

Μια ανεπάρκεια του προγράμματος που διαπιστώθηκε και δεν μπόρεσε να διορθωθεί είναι ότι ο αριθμός των μηχανών που χρησιμοποιούνται σε κάθε παραγγελία θα πρέπει να διαιρεί _ακριβώς_ τον αριθμό των προϊόντων, διαφορετικά δε θα δοθεί λύση. Δεν μπόρεσε να βρεθεί κάποια υλοποίηση που να υποστηρίζεται από την ECLiPSe, και ευτυχώς τα δεδομένα της άσκησης δεν παρουσιάζουν τέτοια προβλήματα. Για παράδειγμα ο τελεστής ακέραιας διαίρεσης `//` δεν υποστηρίζεται σε περιορισμούς, και χρησιμοποιήθηκε ο τελεστής `/` που πετυχαίνει μόνο όταν το αποτέλεσμα της διαίρεσης είναι ακέραιο.

Διαπιστώθηκε επίσης ότι το κατηγόρημα `labeling` δέχεται και λίστες λιστών, όπως έγινε στην τελευταία γραμμή αντί της χρήσης του κατηγορήματος `append`. Χρειάστηκε να περαστούν οι μεταβλητές και των χρόνων έναρξης και της κατανομής των μηχανών, επειδή και οι δύο είναι ανεξάρτητες.
