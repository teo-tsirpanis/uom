# Χρήση του αλγορίθμου Aho-Corasick στη βιβλιοθήκη κανονικών εκφράσεων του .NET.

### Τσιρπάνης Θεόδωρος `dai19090`

## Εισαγωγή

### Ο αλγόριθμος Aho-Corasick

Ο [αλγόριθμος Aho-Corasick](https://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_algorithm) είναι ένας αλγόριθμος αναζήτησης κειμένου που εφευρέθηκε από τους Alfred V. Aho και Margaret J. Corasick το 1975. Δέχεται σαν είσοδο ένα σύνολο συμβολοσειρών (τις _λέξεις_), το προεπεξεργάζεται, και δημιουργεί μια μηχανή καταστάσεων βασισμένη σε ένα δέντρο συμβολισειρών (_trie_), με την οποία μπορεί σε αυθαίρετο κείμενο να βρει παρουσίες μίας εκ των λέξεων.

Για την λειτουργία του αλγορίθμου, κάθε κόμβος του δέντρου επαυξάνεται με τρεις τιμές:

* Κάθε κόμβος έχει μια δυαδική τιμή που προσδιορίζει αν η συμβολοσειρά που του αντιστοιχεί ανήκει στις λέξεις που θέλουμε να βρούμε. Σε αυτήν την περίπτωση λέμε ότι είναι _κόμβος αντιστοίχισης_.
* Ο _σύνδεσμος επιθήματος_ (suffix link) ενός κόμβου $A$ είναι ο κόμβος $B$ που αντιστοιχεί στο μεγαλύτερο επίθημα της συμβολοσειράς του $A$ που ανήκει στο δέντρο. Το επίθημα αυτό μπορεί να είναι η κενή συμβολοσειρά, η οποία αντιστοιχεί στη ρίζα του δέντρου. Εκτός από την ρίζα, ο σύνδεσμος επιθήματος ενός κόμβου δεν μπορεί να είναι ο ίδιος με τον εαυτό του.
* Ο _σύνδεσμος ευρετηρίου_ (dictionary link) ενός κόμβου $A$ είναι ο κόμβος $B$ που αντιστοιχεί στο μακρύτερο επίθημα της συμβολοσειράς του $A$ που ανήκει στο δέντρο και στις λέξεις που θέλουμε να βρούμε. Αν δεν υπάρχει, το επίθημα αυτό μπορεί να είναι η κενή συμβολοσειρά, η οποία αντιστοιχεί στη ρίζα του δέντρου. Εκτός από την ρίζα, ο σύνδεσμος ευρετηρίου ενός κόμβου δεν μπορεί να είναι ο ίδιος με τον εαυτό του.

Ο τρόπος αποδοτικού υπολογισμού των τιμών συνδέσμου του κάθε κόμβου παραλείπεται.

Ο αλγόριθμος αναζήτησης διαβάζει από την συμβολοσειρά εισόδου έναν χαρακτήρα ανά φορά, και διατηρεί μεταξύ των επαναλήψεων μια μεταβλητή που δηλώνει τον τωρινό κόμβο του δέντρου που βρίσκεται, ο οποίος είναι αρχικά η ρίζα του δέντρου.

Σε κάθε επανάληψη πραγματοποιούνται τα εξής, όπου $i$ η τρέχουσα θέση της συμβολοσειράς εισόδου (με τον πρώτο χαρακτήρα να είναι στη θέση $0$) και $c$ ο τρέχον χαρακτήρας της εισόδου:

1. Από τον τωρινό κόμβο του δέντρου ελέγχουμε αν υπάρχει μετάβαση μέσω του χαρακτήρα $c$ σε κάποιον κόμβο.
    * Αν υπάρχει, θέτουμε τον τωρινό κόμβο σε αυτόν που οδηγεί η μετάβαση, και πηγαίνουμε στο βήμα 2.
    * Αν δεν υπάρχει:
        * Αν ο τωρινός κόμβος είναι η ρίζα του δέντρου, πηγαίνουμε στο βήμα 2.
        * Αν δεν είναι, θέτουμε τον τωρινό κόμβο στον σύνδεσμο επιθήματός του, και επαναλαμβάνουμε το βήμα 1.
2. Από τον τωρινό κόμβο του δέντρου, ανατρέχουμε προς τα πίσω μέσω των συνδέσμων ευρετηρίου, μέχρι να φτάσουμε στη ρίζα του δέντρου. Για κάθε κόμβο $x$ που συναντάμε και που η συμβολοσειρά του ανήκει στις λέξεις που θέλουμε να βρούμε, κάνουμε τα εξής:
    * Έστω $matchPos = i + 1 - length(x)$ η θέση της λέξης που βρήκαμε, όπου $length(x)$ το μήκος της συμβολοσειράς που αντιστοιχεί στον κόμβο $x$ (αν δεν το έχουμε κρατήσει κάπου, μπορούμε να το υπολογίσουμε εύκολα βρίσκοντας το ύψος του κόμβου στο δέντρο).
    * Άναφέρουμε με κάποιον τρόπο ότι έχουμε βρει τη λέξη που αντιστοιχεί στον κόμβο $x$, στη θέση $matchPos$.

### Η βιβλιοθήκη κανονικών εκφράσεων του .NET

Από την πρώτη του κυκλοφορία το 2002, το προγραμματιστικό περιβάλλον .NET προσφέρει μια πλούσια βιβλιοθήκη κανονικών εκφράσεων, η οποία βρίσκεται στο namespace `System.Text.RegularExpressions`. Τα τελευταία χρόνια υπέστη σημαντικές βελτιώσεις στις εκδόσεις [.NET 5](https://devblogs.microsoft.com/dotnet/regex-performance-improvements-in-net-5/) και [.NET 7](https://devblogs.microsoft.com/dotnet/regular-expression-improvements-in-dotnet-7/), το οποίο θα κυκλοφορήσει τον Νοέμβριο του 2022.

Η χρήση της βιβλιοθήκης ξεκινάει με την κλάση `Regex`. Δημιουργούμε ένα αντικείμενο αυτού του τύπου, δίνοντας στον δημιουργό το μοτίβο και [επιπλέον επιλογές](https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regexoptions?view=net-7.0), και το χρησιμοποιούμε για να κάνουμε αντιστοιχήσεις σε κείμενο.

Ακολουθεί ένα απλό παράδειγμα χρήσης, παρμένο από [την τεκμηρίωση της κλάσης](https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex?view=net-7.0#examples):

```csharp
using System;
using System.Text.RegularExpressions;

// Define a regular expression for repeated words.
Regex rx = new Regex(@"\b(?<word>\w+)\s+(\k<word>)\b",
    RegexOptions.Compiled | RegexOptions.IgnoreCase);

// Define a test string.
string text = "The the quick brown fox  fox jumps over the lazy dog dog.";

// Find matches.
MatchCollection matches = rx.Matches(text);

// Report the number of matches found.
Console.WriteLine($"{matches.Count} matches found in:\n   {text}");

// Report on each match.
foreach (Match match in matches)
{
    GroupCollection groups = match.Groups;
    Console.WriteLine($"'{groups["word"].Value}' repeated at positions {groups[0].Index} and {groups[1].Index}");
}

// The example produces the following output to the console:
//       3 matches found in:
//          The the quick brown fox  fox jumps over the lazy dog dog.
//       'The' repeated at positions 0 and 4
//       'fox' repeated at positions 20 and 25
//       'dog' repeated at positions 49 and 53
```

> Το παράδειγμα έχει τροποποιηθεί από αυτό της τεκμηρίωσης για να χρησιμοποιεί νέες λειτουργίες της γλώσσας. Οι διαφορές είναι ενδιαφέρουσες· [δεν υπάρχει `Main`](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/program-structure/top-level-statements), και χρησιμοποιούνται [interpolated strings](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated), [τα οποία έγιναν πιο αποδοτικά στο .NET 6](https://devblogs.microsoft.com/dotnet/string-interpolation-in-c-10-and-net-6/).

Κατά τη δημιουργία του αντικειμένου `Regex`, το μοτίβο υφίσταται συντακτική ανάλυση, και μετατρέπεται σε ένα συντακτικό δέντρο, το οποίο βελτιστοποιείται και περνιέται σε κάποια από τις υλοποιήσεις της βιβλιοθήκης που θα αναλάβει την αντιστοίχιση του κειμένου. Προσφέρονται τέσσερις υλοποιήσεις, εκ των οποίων οι δύο προστέθηκαν στο .NET 7:

* Η __διερμηνευόμενη__ υλοποίηση μετατρέπει το μοτίβο σε μια σειρά εντολών μιας απλής μηχανής στοίβας, που κατά την αντιστοίχιση εκτελούνται από έναν διερμηνέα. Είναι η προεπιλεγμένη υλοποίηση.
* Η __μεταγλωττισμένη__ υλοποίηση μετατρέπει το μοτίβο σε bytecode του .NET (ονομάζεται _IL_ από το Intermediate Language) το οποίο μεταγλωττίζεται σε native γλώσσα μηχανής από το JIT. Πληρώνοντας ένα υψηλότερο κόστος αρχικοποίησης, πετυχαίνουμε σημαντικά καλύτερες επιδόσεις από τη διερμηνευόμενη υλοποίηση. Χρησιμοποιείται περνώντας την επιλογή `RegexOptions.Compiled` κατά τη δημιουργία του αντικειμένου `Regex`. Στις πλατφόρμες που δεν υποστηρίζουν παραγωγή μεταγλωττισμένου δυναμικού κώδικα (όπως iOS και WebAssembly) χρησιμοποιείται αντ' αυτής η διερμηνευόμενη υλοποίηση.
*
    Η υλοποίηση με __παραγόμενο πηγαίο κώδικα__ είναι καινούργια στο .NET 7 και χρησιμοποιεί επεκτάσεις του μεταγλωττιστή της C# που λέγονται [_γεννήτριες πηγαίου κώδικα_ (source generators)](https://docs.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/source-generators-overview). Ας δούμε πρώτα ένα παράδειγμα χρήσης της:

    ```csharp
    using System;
    using System.Text.RegularExpressions;

    Regex rx = MyRegex.GetMyRegex();

    // Define a test string.
    string text = "The the quick brown fox  fox jumps over the lazy dog dog.";

    // Find matches.
    int matches = rx.Count(text);

    // Report the number of matches found.
    Console.WriteLine($"{matches} matches found in:\n   {text}");

    internal static partial class MyRegex
    {
        // Define a regular expression for repeated words.
        [GeneratedRegex(@"\b(?<word>\w+)\s+(\k<word>)\b", RegexOptions.IgnoreCase)]
        public static partial Regex GetMyRegex();
    }
    ```

    Ορίζουμε τη μέθοδο `GetMyRegex` χωρίς υλοποίηση και με τη λέξη `partial`, που σημαίνει ότι η υλοποίησή της βρίσκεται σε κάποιο άλλο αρχείο, το οποίο θα το παράξει ο μεταγλωττιστής της C# όταν "χτίσουμε" το πρόγραμμα, και θα περιέχει εξειδικευμένο κώδικα σε C# για να αντιστοιχίσει το μοτίβο μας. Η χρήση του source generator προτείνεται σε κάθε περίπτωση όπου το μοτίβο είναι γνωστό κατά τη μεταγλώττιση, και με μόνο αρνητικό μια ελαφρά αύξηση του μεγέθους του μεταγλωττισμένου αρχείου, προσφέρει μια πληθώρα πλεονεκτημάτων:

    * Το κόστος αρχικοποίησης του αντικειμένου `Regex` εκμηδενίζεται. Δεν χρειάζεται όταν εκτελέσουμε το πρόγραμμα να αναλύσουμε το μοτίβο, αυτό έγινε όταν μεταγλωττίσαμε το πρόγραμμα!
        * Αυτό επίσης σημαίνει ότι τα σχετικά τμήματα της βιβλιοθήκης μπορούν να [περικοπούν](https://docs.microsoft.com/en-us/dotnet/core/deploying/trimming/trim-self-contained), μειώνοντας το μέγεθος της τελικής εφαρμογής.
    * Η απόδοση της αντιστοίχισης είναι ισάξια της μεταγλωττισμένης υλοποίησης (οι δύο υλοποιήσεις παράγουν ισοδύναμο κώδικα σε IL και C# αντίστοιχα), και χωρίς κανένα μειονέκτημα· επειδή δεν παράγεται κώδικας δυναμικά, μπορεί να χρησιμοποιηθεί οπουδήποτε υποστηρίζεται το .NET.
    * Επειδή μπορούμε να δούμε τον παραγόμενο κώδικα, μπορούμε να βάλουμε breakpoints και να τον εκσφαλματώσουμε για να διαγνώσουμε λάθη στο μοτίβο μας, ή να μάθουμε πώς λειτουργεί. Ο παραγόμενος κώδικας είναι επίσης σχολιασμένος, βοηθώντας μας στο δεύτερο.
* Η υλοποίηση __χωρίς οπισθοδρόμηση__ είναι επίσης καινούργια στο .NET 7, και εντελώς διαφορετική από τις προηγούμενες, βασιζόμενη στον [Symbolic Regex Matcher](https://www.microsoft.com/en-us/research/publication/symbolic-regex-matcher/), ένα ερευνητικό έργο της Microsoft Research που χρησιμοποιεί πεπερασμένα αυτόματα. Στόχος της είναι να αποφύγει τις λεγόμενες ["καταστροφικές οπισθοδρομήσεις" που οδηγούν σε εκθετικό χρόνο αντιστοίχισης και αποτελούν πηγή επιθέσεων άρνησης υπηρεσίας](https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS). Περιορίζοντας ορισμένες δυνατότητες των κανονικών εκφράσεων όπως τα backreferences (τα παραδείγματα πάνω δε μπορούν να λειτουργήσουν χωρίς οπισθοδρόμηση), η υλοποίηση αυτή εγγυάται γραμμικό χρόνο αντιστοίχισης για κάθε είσοδο. Χρησιμοποιείται περνώντας την επιλογή `RegexOptions.NonBacktracking` κατά τη δημιουργία του αντικειμένου `Regex`. Προς το παρόν δεν είναι συμβατή με τη μεταγλωττισμένη υλοποίηση ή τον source generator.

### Συντομεύσεις στην εύρεση πιθανών αντιστοιχίσεων

Επειδή η αντιστοίχιση μιας κανονικής έκφρασης μπορεί να είναι υπολογιστικά δαπανηρή, και για την αποφυγή περιττών υπολογισμών σε άσχετα σημεία του κειμένου, η βιβλιοθήκη μπορεί ανάλογα με το μοτίβο να πάρει κάποιες "συντομεύσεις" για να ψάξει γρήγορα μέσα στο κείμενο εισόδου για πιθανά σημεία που μπορούν να αποτελέσουν μια αντιστοίχιση, πριν μεταβεί στον ενδελεχή κύριο αλγόριθμο. Αυτή η λογική περιέχεται στην εσωτερική κλάση [`RegexFindOptimizations`](https://github.com/dotnet/runtime/blob/8a26f96b6d0e0c557be1f4a6d67e74391f566f3c/src/libraries/System.Text.RegularExpressions/src/System/Text/RegularExpressions/RegexFindOptimizations.cs), και οι διαφορετικές συντομεύσεις περιγράφονται στην απαρίθμηση [`FindNextStartingPositionMode`](https://github.com/dotnet/runtime/blob/8a26f96b6d0e0c557be1f4a6d67e74391f566f3c/src/libraries/System.Text.RegularExpressions/src/System/Text/RegularExpressions/RegexFindOptimizations.cs#L701-L753). Κάθε κανονική έκφραση μπορεί να χρησιμοποιήσει μόνο μια συντόμευση. Οι διερμηνευόμενες υλοποίησεις χρησιμοποιούν το αντικείμενο `RegexFindOptimizations`, και στις υλοποιήσεις με παραγόμενο κώδικα παράγεται εξειδικευμένος κώδικας για την εκάστοτε συντόμευση.

Οι συντομεύσεις μπορούν να συνοψιστούν ως εξής, κατά φθίνουσα σειρά προτίμησης:

* __Anchors:__ Σε μοτίβα όπως το `^hello world`, ο χαρακτήρας `^` σημαίνει ότι το μοτίβο μπορεί να αντιστοιχιστεί μόνο στην αρχή του κειμένου εισόδου. Αυτό σημαίνει ότι αν έχουμε περάσει την αρχή, δεν υπάρχουν άλλες πιθανές αντιστοιχίσεις και μπορούμε να τελειώσουμε την αναζήτηση. Υπάρχουν συνολικά δέκα συντομεύσεις αυτού του τύπου, για τα διάφορα είδη anchors, και ανάλογα με το αν η αντιστοίχιση γίνεται από τα δεξιά προς τα αριστερά (με την επιλογή `RegexOptions.RightToLeft`). Επειδή αυτές οι συντομεύσεις εκτελούνται σε σταθερό χρόνο, επιλέγονται πάντα αν το μοτίβο περιέχει anchors.
* __Εναρκτήρια συμβολοσειρά:__ Μοτίβα όπως το `Tel: \d{10}` ξεκινούν με μια σταθερή συμβολοσειρά. Χρησιμοποιώντας την συνάρτηση [`IndexOf`](https://docs.microsoft.com/en-us/dotnet/api/system.memoryextensions.indexof) η οποία έχει μια διανυσματοποιημένη υλοποίηση, μπορούμε να ψάξουμε γρήγορα αυτήν την σταθερή συμβολοσειρά, και να μεταβούμε στον κύριο αλγόριθμο μόνο αν την βρούμε. Αν δεν υπάρχει, δεν υπάρχουν άλλες πιθανές αντιστοιχίσεις και μπορούμε να τελειώσουμε την αναζήτηση. Σε αυτήν την κατηγορία ανήκουν οι συντομεύσεις `LeadingString_LeftToRight`, `LeadingString_RightToLeft` και `LeadingChar_RightToLeft`.
*
    __Εναρκτήριο σύνολο:__ Για να ελέγξουν αν ένας χαρακτήρας ανήκει σε ένα σύνολο, οι υλοποιήσεις με παραγόμενο κώδικα μπορούν να παράξουν εξειδικευμένο κώδικα που είναι πολύ πιο αποδοτικός. Σε ένα απλό παράδειγμα, αν έχουμε ένα σύνολο όπως το `\d`, αν ο χαρακτήρας που θέλουμε να ελέγξουμε είναι ο `c`, αντί για `c is '0' or '1' or '2' or '3' or '4' or '5' or '6' or '7' or '8' or '9'` που θα κάνει δέκα συγκρίσεις, θα παράγουμε την συνθήκη `(uint)(c - '0') <= (uint)('9' - '0')` που θα κάνει μία σύγκριση.

    Για να βρούμε μέσα σε μια συμβολοσειρά την πρώτη εμφάνιση ενός από κάποιους χαρακτήρες, το .NET προσφέρει τη συνάρτηση [`IndexOfAny`](https://docs.microsoft.com/en-us/dotnet/api/system.memoryextensions.indexofany?view=net-7.0#system-memoryextensions-indexofany-1(system-readonlyspan((-0))-system-readonlyspan((-0)))), η υλοποίηση της οποίας είναι διανυσματοποιημένη όταν οι χαρακτήρες που θέλουμε να βρούμε είναι το πολύ πέντε. Ανεξάρτητα της υλοποίησης που χρησιμοποιούμε, αν το μοτίβο μας ξεκινάει από ένα τέτοιο μικρό σύνολο, χρησιμοποιούμε την `IndexOfAny` για να βρούμε πιθανές αντιστοιχίσεις ακόμη πιο αποδοτικά. Αν το σύνολο είναι μεγαλύτερο είτε παράγουμε εξειδικευμένο κώδικα αν μπορούμε, είτε καταφεύγουμε σε πιο αργές μεθόδους. Αν δεν βρούμε κάποιον από τους χαρακτήρες του εναρκτήριου συνόλου, δεν υπάρχουν άλλες πιθανές αντιστοιχίσεις και μπορούμε να τελειώσουμε την αναζήτηση. Σε αυτήν την κατηγορία ανήκουν οι συντομεύσεις `LeadingSet_LeftToRight` και `LeadingSet_RightToLeft`.
* __Συμβολοσειρά σε σταθερή απόσταση:__ Το μοτίβο `[^ ]{4} [^ ]{4}` αντιστοιχίζει χαρακτήρες διαστήματος που περικλείονται από τέσσερις χαρακτήρες διαφορετικούς του διαστήματος. Το εναρκτήριο σύνολο του μοτίβου είναι πολύ μεγάλο οπότε δε μπορούμε να χρησιμοποιήσουμε την παραπάνω συντόμευση (στην πραγματικότητα μπορούμε μέσω της συνάρτησης [`IndexOfAnyExcept`](https://docs.microsoft.com/en-us/dotnet/api/system.memoryextensions.indexofanyexcept) αλλά έστω ότι δεν μπορούμε), αλλά αυτό που μπορούμε να κάνουμε είναι να βρούμε το διάστημα, και αν υπάρχει να γυρίσουμε τέσσερις χαρακτήρες πίσω, και να μεταβούμε στον κύριο αλγόριθμο. Αν δεν το βρούμε, δεν υπάρχουν άλλες πιθανές αντιστοιχίσεις και μπορούμε να τελειώσουμε την αναζήτηση. Σε αυτήν την κατηγορία ανήκουν οι συντομεύσεις `FixedDistanceChar_LeftToRight` και `FixedDistanceString_LeftToRight`.
* __Σύνολα σε σταθερές αποστάσεις:__ Το μοτίβο `\d{4} \d{4}` αντιστοιχίζει τέσσερα δεκαδικά ψηφία, έναν χαρακτήρα διαστήματος και άλλα τέσσερα δεκαδικά ψηφία. Εδώ μπορούμε να εκμεταλλευτούμε το εναρκτήριο σύνολο αλλά δεν είναι τόσο μικρό για διανυσματοποιημένη αναζήτηση. Θα χρησιμοποιήσουμε την παραπάνω συντόμευση και θα βρούμε γρήγορα τον χαρακτήρα διαστήματος, αλλά για να περιορίσουμε τα ψευδή θετικά, θα ελέγξουμε αν οι πρώτοι δύο χαρακτήρες της πιθανής αντιστοίχισης είναι δεκαδικά ψηφία, και στην αντίθετη περίπτωση θα ψάξουμε για τον επόμενο χαρακτήρα διαστήματος και θα επαναλάβουμε τη διαδικασία. Για λόγους εξοικονόμησης χρόνου χρησιμοποιούνται μέχρι τρία σύνολα· αν υπάρχουν περισσότερα επιλέγονται αυτά με τους πιο σπάνιους χαρακτήρες [βάσει ενός πίνακα συχνότητας που υπολογίστηκε από τα αρχεία C# του αποθετηρίου `dotnet/runtime` και τα 25 πιο δημοφιλή βιβλία του Project Gutenberg](https://github.com/dotnet/runtime/blob/347847265d0832def96a2ff4057029999ffc70b1/src/libraries/System.Text.RegularExpressions/src/System/Text/RegularExpressions/RegexPrefixAnalyzer.cs#L868-L944). Σε αυτήν την κατηγορία ανήκει η συντόμευση `FixedDistanceSets_LeftToRight`.
* __Συμβολοσειρά μετά από επανάληψη:__ Το μοτίβο `[1-9]*0` αντιστοιχίζει καμία ή πολλές επαναλήψεις των ψηφίων ένα έως εννιά, ακολουθούμενα από το ψηφίο μηδέν. Θα μπορούσαμε να θέσουμε ως εναρκτήριο σύνολο το `[0-9]` αλλά  δεν θα το κάνουμε επειδή είναι πολύ μεγάλο για να διανυσματοποιηθεί η αναζήτηση. Αντ' αυτού θα ψάξουμε το μηδέν με τη διανυσματοποιημένη `IndexOf`, και αν το βρούμε θα γυρίσουμε προς τα πίσω μέχρι να βρούμε χαρακτήρα που δεν ανήκει στο `[1-9]`, και από εκεί θα μεταβούμε στον κύριο αλγόριθμο. Αν δε το βρούμε, δεν υπάρχουν άλλες πιθανές αντιστοιχίσεις και μπορούμε να τελειώσουμε την αναζήτηση. Σε αυτήν την κατηγορία αντιστοιχεί η συντόμευση `LiteralAfterLoop_LeftToRight`.
* __Τίποτα:__ Αν δεν ισχύουν οι συνθήκες για καμία από τις παραπάνω συντομεύσεις, προχωράμε κατευθείαν στον κύριο αλγόριθμο. Σε αυτήν την κατηγορία ανήκει η "συντόμευση" `NoSearch`.

## Τι προστέθηκε

Στην παραπάνω λίστα προσθέτουμε μια νέα κατηγορία συντομεύσεων:

* __Πολλαπλές εναρκτήριες συμβολοσειρές:__ Μοτίβα όπως το `monday|tuesday|wednesday|thursday|friday|saturday|sunday` ξεκινούν με μία από ένα πεπερασμένο σύνολο συμβολοσειρών. Μπορούμε να χρησιμοποιήσουμε τον αλγόριθμο Aho-Corasick για να βρούμε πιθανές αντιστοιχίσεις στο κείμενο εισόδου, με μεγαλύτερη ακρίβεια από μία σκέτη χρήση του εναρκτήριου συνόλου `[mtwfs]`. Σε αυτήν την κατηγορία ανήκει η συντόμευση `LeadingMultiString_LeftToRight`.

Το πρόβλημα της ενσωμάτωσης του αλγορίθμου Aho-Corasick μπορεί να διαιρεθεί σε τρία υποπροβλήματα, ταξινομημένα κατά αύξουσα σειρά δυσκολίας:

* Πρέπει να προσαρμόσουμε τον αλγόριθμο στις ανάγκες μας.
* Πρέπει να πάρουμε από το μοτίβο τις λέξεις που θα δώσουμε στον αλγόριθμο για να βρει.
* Πρέπει να αποφασίσουμε πότε συμφέρει να χρησιμοποιηθεί ο Aho-Corasick αντί για κάποια άλλη συντόμευση.

### Τροποποιήσεις στον αλγόριθμο Aho-Corasick

Ο αλγόριθμος Aho-Corasick που περιγράψαμε στην αρχή βρίσκει _όλες_ τις λέξεις στο κείμενο εισόδου, καθώς και _ποια_ από αυτές βρέθηκε κάθε φορά. Όμως οι απαιτήσεις μας για την γρήγορη εύρεση πιθανών αντιστοιχίσεων είναι μικρότερες. Πρώτον, σε κάθε εκτέλεση του αλγορίθμου θέλουμε να βρούμε μόνο την πρώτη λέξη μέσα στο κείμενο εισόδου και δεύτερον, δε μας ενδιαφέρει συγκεκριμένα ποια από τις λέξεις βρήκαμε. Με βάση αυτά μπορούμε να κάνουμε τις ακόλουθες τροποποιήσεις στον αρχικό αλγόριθμο.

*
    Κάθε κόμβος έχει μια τιμή που ονομάζεται _μήκος αντιστοίχισης_ και ορίζεται ως εξής:
    * Αν η συμβολοσειρά που αντιστοιχεί στον κόμβο ανήκει στις λέξεις που θέλουμε να βρούμε, το μήκος αντιστοίχισής της είναι ίσο με το μήκος της συμβολοσειράς αυτής.
    * Σε αντίθετη περίπτωση είναι ίσο με το μήκος της συμβολοσειράς που αντιστοιχεί στον σύνδεσμο ευρετηρίου του κόμβου.
* Δεν χρειάζονται για την αναζήτηση η τιμή του συνδέσμου ευρετηρίου του κάθε κόμβου και το αν ο κόμβος είναι κόμβος αντιστοίχισης.
*
    Το δεύτερο βήμα του αλγορίθμου αναζήτησης αντικαθίσταται ως εξής:
    > Έστω $matchLength$ η τιμή του μήκους αντιστοίχισης του τωρινού κόμβου. Αν $matchLength \ne 0$ σταματάμε την αναζήτηση αναφέροντας ότι βρήκαμε μια λέξη στη θέση $i + 1 - matchLength$.
* Επειδή με το που βρούμε μια λέξη σταματάμε, μπορούμε να περιορίσουμε τις λέξεις που θέλουμε να βρούμε, παραλείποντας αυτές στις οποίες θέλουμε να βρούμε ένα μη κενό πρόθημά τους. Για παράδειγμα αν θέλουμε να βρούμε τη λέξη `a`, δεν χρειάζεται να προσθέσουμε τη λέξη `ab`.

Η υλοποίηση του αλγορίθμου βρίσκεται στην κλάση [`MultiStringMatcher`](https://github.com/teo-tsirpanis/dotnet-runtime/blob/aho-corasick/src/libraries/System.Text.RegularExpressions/src/System/Text/RegularExpressions/MultiStringMatcher.cs). Οι διερμηνευόμενες υλοποιήσεις χρησιμοποιούν την κλάση κατευθείαν, ενώ για τις άλλες παράγεται εξειδικευμένος κώδικας για το κάθε δέντρο. Ενδεικτικός παραγόμενος πηγαίος κώδικας παρατίθεται στο τέλος της αναφοράς.

### Δημιουργία του δέντρου συμβολοσειρών

Το παράδειγμα που δείξαμε πριν με τις ημέρες της εβδομάδας ακολουθεί ένα μοτίβο της μορφής `a|b|c|d|e` από το οποίο μπορούμε εύκολα να εντοπίσουμε τις λέξεις που θέλουμε να προσθέσουμε στο δέντρο συμβολοσειρών. Όμως, υπάρχουν πολλά ακόμα πιθανά μοτίβα που θέλουμε να υποστηρίξουμε, και γι' αυτό χρειαζόμαστε έναν γενικό αλγόριθμο.

Η ιδέα του αλγορίθμου είναι ότι αφού δημιουργήσουμε τη ρίζα του δέντρου, διασχίζουμε το μοτίβο από αριστερά προς τα δεξιά, προσθέτοντας χαρακτήρες στους κόμβους μέχρι να φτάσουμε σε κάποιο μη σταθερό σημείο του μοτίβου, λαμβάνοντας υπ' όψιν εναλλακτικά μονοπάτια που μπορούν να παρθούν. Σε κάθε βήμα του αλγορίθμου κρατάμε κάποιους κόμβους "στο χέρι μας", τους οποίους θα αναπτύσσουμε προσθέτοντας τους χαρακτήρες που συναντάμε σε αυτούς.

Ο κάθε κόμβος αναπαρίσταται με την κλάση `TrieNode` και κρατάει πληροφορίες όπως το βάθος του, τον γονικό του κόμβο, ένα ευρετήριο χαρακτήρα-κόμβου με τα παιδιά του, και τον χαρακτήρα με τον οποίο μεταβήκαμε σε αυτόν. Όλοι οι κόμβοι αποθηκεύονται σε μια λίστα, με τη ρίζα να βρίσκεται στην αρχή. Αναφορές μεταξύ των κόμβων γίνονται με τη θέση τους στη λίστα και όχι με το αντικείμενό τους.

Για παράδειγμα, το μοτίβο $a(b|c)de*$ αναλύεται ως εξής:

* Δημιουργούμε τη ρίζα, και τη βάζουμε στο χέρι μας.
* Συναντάμε τον χαρακτήρα $a$ και προσθέτουμε στη ρίζα έναν νέο κόμβο που αντιστοιχεί στη συμβολοσειρά $a$, και τον κρατάμε στο χέρι μας.
* Συναντάμε τη δομή εναλλαγής $b|c$, και εκτελώντας αναδρομικά τον αλγόριθμο, προσθέτουμε μετά τον κόμβο του $a$, το $b$ στη μία διακλάδωση και το $c$ στην άλλη, αφήνοντας στο χέρι μας τους κόμβους $ab$ και $ac$ αντίστοιχα. Συγχωνεύουμε τα χέρια των διακλαδώσεων, και κρατάμε στο χέρι μας και τον $ab$ και τον $ac$.
* Συναντάμε τον χαρακτήρα $d$, και το προσθέτουμε στους κόμβους $ab$ και $ac$. Κρατάμε στο χέρι μας τους κόμβους $abd$ και $acd$.
* Συναντάμε τη δομή επανάληψης $e*$ αλλά δε μπορούμε να προσθέσουμε κάποιον χαρακτήρα, επειδή αντιστοιχίζουμε από μηδέν μέχρι άπειρες εμφανίσεις του $e$ και δεν υπάρχει κάποιο σταθερό μέρος στην έκφραση, που σημαίνει ότι σταματάμε την επανάληψη εδώ, και μαρκάρουμε τους κόμβους που κρατάμε στο χέρι μας ως κόμβους αντιστοίχισης. Το δέντρο μας θα αντιστοιχίζει τις συμβολοσειρές $abd$ και $acd$.

Αν ένας κόμβος έχει ήδη μια μετάβαση με κάποιον χαρακτήρα, δεν θα δημιουργήσουμε έναν καινούργιο, αλλά θα πάρουμε τον υπάρχοντα κόμβο και θα τον κρατήσουμε στο χέρι μας. Κάτι τέτοιο συμβαίνει στο μοτίβο $aa|ab$, όταν πάμε στη δεύτερη διακλάδωση.

Η ισχύς του αλγορίθμου αναδεικνύεται στην περίπτωση που η ροή "κόβεται" σε κάποιες αλλά όχι όλες τις διακλαδώσεις. Ένα παράδειγμα είναι το μοτίβο $a(b|c|d+)e$. Προσθέτουμε το $a$ στη ρίζα κανονικά, προσθέτουμε το $ab$ και το $ac$ όπως στο προηγούμενο παράδειγμα, αλλά φτάνοντας στο $d+$ (που είναι ισοδύναμο με το $dd*$), προσθέτουμε το $ad$, αλλά δε μπορούμε να συνεχίσουμε μετά το $d*$. Αυτό που κάνουμε είναι να μαρκάρουμε το $ad$ ως κόμβο αντιστοίχισης, και να συνεχίσουμε κρατώντας στο χέρι μας μόνο τους $ab$ και $ac$, προσθέτοντας σε αυτούς το $e$. Το δέντρο μας θα αντιστοιχίζει τις συμβολοσειρές $abe$, $ace$ και $ad$.

> Γενικεύοντας, το .NET αναπαριστά τους ποσοδείκτες ως δομές επανάληψης. Για παράδειγμα το $x*$ αναπαρίσταται ως $x\{0,∞\}$, και το $x+$ ως $x\{1,∞\}$. Αν ο αλγόριθμός μας συναντήσει μια δομή επανάληψης της μορφής $x\{m,n\}$, θα προσθέσει το $x$ (το οποίο δεν χρειάζεται να είναι χαρακτήρας αλλά μια αυθαίρετα σύνθετη έκφραση) $m$ φορές, και θα συνεχίσει μόνο αν $m = n$.
>
> Αν $m \ne n$, δεν αναπτύσσουμε την επανάληψη (για παράδειγμα μετατρέποντας το $a\{2,4\}$ σε $aa|aaa|aaaa$) επειδή δεν θέλουμε να παράγουμε υπερβολικά πολλούς κόμβους, με μόνη εξαίρεση την περίπτωση όπου η έκφραση είναι της μορφής $x\{0,1\}$, που αντιστοιχεί στο μοτίβο $x?$ και δεν βρίσκεται στο τέλος. Αυτό μας επιτρέπει να χειριστούμε μοτίβα όπως το $a?bc$ και να πάρουμε τις λέξεις $abc$ και $bc$.

Υπάρχει επίσης περίπτωση να μαρκαριστεί ως κόμβος αντιστοίχισης _η ρίζα_, όπως συμβαίνει στο μοτίβο $(a|b|c*)$. Τη στιγμή που συνειδητοποιούμε ότι η τρίτη διακλάδωση δε μπορεί να συνεχίσει, κρατούσαμε στο χέρι μας τη ρίζα και επομένως τη μαρκάρουμε. Αν συμβεί αυτό, το δέντρο είναι άχρηστο και ο αλγόριθμος Aho-Corasick δε μπορεί να χρησιμοποιηθεί. Υπάρχουν δύο εξηγήσεις γι' αυτό, μία από την οπτική του δέντρου και μία από την οπτική του μοτίβου:

* Αν η ρίζα είναι κόμβος αντιστοίχισης, αυτό σημαίνει ότι στις λέξεις του Aho-Corasick ανήκει η κενή συμβολοσειρά, και επειδή σταματάμε με το που βρούμε μια λέξη, βρίσκουμε την κενή συμβολοσειρά στην αρχή του κειμένου, και η αναζήτηση δεν έχει νόημα!
* Όταν ο αλγόριθμός μας συναντήσει μια δομή εναλλαγής, πρέπει να λάβει υπ' όψιν είτε _όλες_ τις διακλαδώσεις είτε _καμία_. Δε θα μπορούσαμε για παράδειγμα να αγνοήσουμε την τρίτη διακλάδωση επειδή το δέντρο θα ήταν λάθος επειδή κατά την αντιστοίχιση του μοτίβου θα προσπερνούσε τυχόν εμφανίσεις του χαρακτήρα $c$. Γενικότερα, ο αλγόριθμός μας βρίσκει ένα εναρκτήριο σταθερό τμήμα στο μοτίβο. Αν στις λέξεις του Aho-Corasick ανήκει η συμβολοσειρά $x$, αυτό σημαίνει ότι στο κείμενο, μετά από το $x$ μπορεί να υπάρχει "κάτι άλλο". Αν υπάρχει η κενή συμβολοσειρά, αυτό το "κάτι άλλο" μπορεί να εμφανιστεί χωρίς μια σταθερή συμβολοσειρά πριν από αυτό, αλλά ο Aho-Corasick μπορεί βρει μόνο σταθερές συμβολοσειρές.

Για την αποφυγή υπερβολικού χρόνου εκτέλεσης ή χρήσης μνήμης, έχουν τεθεί κάποια αυθαίρετα όρια στον αλγόριθμο:

* Οι συμβολοσειρές του δέντρου δεν μπορούν να είναι μεγαλύτερες από __12__ χαρακτήρες.
* Το δέντρο δεν μπορεί να έχει περισσότερους από __128__ κόμβους (ή __256__ στις υλοποιήσεις με παραγόμενο κώδικα, μιας και έχουμε περισσότερο χρόνο στη διάθεσή μας).
* Σύνολα που αντιστοιχίζουν πάνω από __16__ χαρακτήρες ή που αντιστοιχίζουν όλους εκτός από ορισμένους (όπως τα `[a-z]` ή `[^ ]` αντίστοιχα) δεν υποστηρίζονται.

Αν η προσθήκη ενός κόμβου θα παραβιάσει κάποιο από τα όρια, ο κόμβος δεν προστίθεται και εφαρμόζεται η προηγούμενη παράγραφος περι "διακοπής" της ροής. Το ίδιο συμβαίνει αν ο αλγόριθμος συναντήσει δομές κανονικών εκφράσεων που δεν αντιστοιχούν σε σταθερές συμβολοσειρές, όπως backreferences. [Άλλες δομές που δεν προσθέτουν χαρακτήρες αγνοούνται.](https://github.com/teo-tsirpanis/dotnet-runtime/blob/752473231ee952db44223f698ddd2d2af5599aa7/src/libraries/System.Text.RegularExpressions/src/System/Text/RegularExpressions/TrieBuilder.cs#L448-L464)

Η υλοποίηση του αλγορίθμου βρίσκεται στο αρχείο [`TrieBuilder.cs`](https://github.com/teo-tsirpanis/dotnet-runtime/blob/752473231ee952db44223f698ddd2d2af5599aa7/src/libraries/System.Text.RegularExpressions/src/System/Text/RegularExpressions/TrieBuilder.cs). Η κλάση των κόμβων του δέντρου που χρησιμοποιεί ο αλγόριθμος δημιουργίας του δέντρου βρίσκεται στο αρχείο [`TrieNode.cs`](https://github.com/teo-tsirpanis/dotnet-runtime/blob/752473231ee952db44223f698ddd2d2af5599aa7/src/libraries/System.Text.RegularExpressions/src/System/Text/RegularExpressions/TrieNode.cs).

> Η κλάση `TrieNode` δεν περιέχει πεδία για τις τιμές που χρειάζεται ο Aho-Corasick· αυτές βρίσκονται στον τύπο `TrieNodeWithLinks` που βρίσκεται στο αρχείο `MultiStringMatcher.cs`.

### Επιλογή χρήσης του Aho-Corasick

Ο αλγόριθμος Aho-Corasick δεν είναι ασημένια σφαίρα, και δεν συμφέρει πάντα να χρησιμοποιήσουμε αυτόν έναντι κάποιας άλλης συντόμευσης. Το πρόβλημα του να αποφασίσουμε πότε θα τον χρησιμοποιήσουμε είναι το δυσκολότερο από τα τρία υποπροβλήματα της ενσωμάτωσης, επειδή δεν λύνεται _ακριβώς_ με αλγόριθμο αλλά _προσεγγιστικά_ με ευρετικούς κανόνες.

Θα ήταν πιο βολικό αν μπορούσαμε να τοποθετήσουμε την συντόμευση πολλαπλών εναρκτήριων συμβολοσειρών κάπου ανάμεσα στη σειρά προτίμησης των συντομεύσεων, αλλά δε μπορούμε να το κάνουμε, επειδή υπάρχει μια σύγκρουση με την συντόμευση της εναρκτήριας συμβολοσειράς, όπως φαίνεται σε μοτίβα όπως το `ab(cd|ef)`· αν βάζαμε τον Aho-Corasick μετά την εναρκτήρια συμβολοσειρά, δε θα είχαμε καν την ευκαιρία να τον χρησιμοποιήσουμε, οπότε χρειαζόμαστε πιο σύνθετους κανόνες.

Αυτοί είναι με τη σειρά οι κανόνες προτίμησης συντομεύσεων την στιγμή που γράφεται το κείμενο (αναμένεται να αλλάξουν στο μέλλον):

1. Όπως είπαμε πριν, αν μπορούμε να χρησιμοποιήσουμε anchors το κάνουμε και σταματάμε, είναι η απολύτως καλύτερη συντόμευση.
2.
    Διαλέγουμε μεταξύ των συντομεύσεων μίας και πολλαπλών εναρκτήριων συμβολοσειρών, ως εξής:
    1. Δεν προσπαθούμε καν να χρησιμοποιήσουμε τον Aho-Corasick και πάμε στο βήμα 2.4 αν:
        * Χρησιμοποιούμε την υλοποίηση χωρίς οπισθοδρόμηση, επειδή η ίδια η υλοποίηση λειτουργεί με έναν παρόμοιο τρόπο· ας μην το κάνουμε δυο φορές.
        * Χρησιμοποιούμε τη λειτουργία αντιστοίχισης από τα δεξιά προς τα αριστερά, επειδή για να την υποστηρίξουμε θα χρειαζόταν να αντιστρέψουμε όλες τις επαναλήψεις στην δημιουργία του δέντρου και στην αντιστοίχιση, και η λειτουργία αυτή δεν είναι αρκετά συνηθισμένη για να αξίζει τον κόπο.
    2. Προσπαθούμε να δημιουργήσουμε ένα δέντρο συμβολοσειρών από το μοτίβο μας, χρησιμοποιώντας τον αλγόριθμο που περιγράψαμε στην προηγούμενη ενότητα. Για εξοικονόμηση υπολογισμών, στο δέντρο δεν αναθέτουμε ακόμα τις τιμές που χρειάζονται για τον Aho-Corasick. Αν δε μπορέσουμε να δημιουργήσουμε ένα δέντρο πάμε στο βήμα 3 και δεν προσπαθούμε καν να βρούμε εναρκτήρια συμβολοσειρά· για να μη μπορέσουμε να σχηματίσουμε ένα δέντρο δε θα υπάρχει. Υπάρχουν δύο πιθανοί λόγοι αποτυχίας:
        * Το δέντρο έχει μόνο έναν κόμβο -τη ρίζα-, που σημαίνει ότι δεν καταφέραμε να προσθέσουμε κανέναν άλλον.
        * Η ρίζα του δέντρου είναι κόμβος αντιστοίχισης, για τους λόγους που εξηγήσαμε στην προηγούμενη υποενότητα.
    3. Αποφασίζουμε αν το δέντρο είναι κατάλληλο για χρήση. Αν είναι, πάμε στο βήμα 3, αλλιώς συνεχίζουμε στο βήμα 2.4. Ένα δέντρο δεν είναι κατάλληλο αν:
        * Υπάρχει ένα μονοπάτι κόμβων με ένα παιδί που ξεκινάει από τη ρίζα και καταλήγει σε κάποιον κόμβο αντιστοίχισης, που σημαίνει ότι όλες οι συμβολοσειρές του δέντρου ξεκινάνε με το ίδιο πρόθημα το οποίο ανήκει στις λέξεις που θέλουμε να βρούμε.
        * Περιέχει λιγότερους από __2__ κόμβους αντιστοίχισης, ή __5__ στις υλοποιήσεις με παραγόμενο κώδικα. Το όριο αυτό προέκυψε από μετρήσεις απόδοσης (benchmarks)· οι μεταγλωττισμένες υλοποιήσεις χρειάζονται μεγαλύτερα δέντρα για να γίνουν γρήγορες, ενώ στις διερμηνευόμενες βλέπουμε βελτιώσεις και με το κατώτατο πλήθος των δύο (ένα δέντρο με έναν κόμβο αντιστοίχισης σημαίνει ότι έχουμε μόνο μία εναρκτήρια σταθερή συμβολοσειρά).
        * Όλοι οι κόμβοι του εκτός από τη ρίζα είναι κόμβοι αντιστοίχισης. Αυτό αποτρέπει μοτίβα όπως το `[0-9]` από το να χρησιμοποιήσουν τον Aho-Corasick· το εναρκτήριο σύνολο είναι μια πολύ καλύτερη συντόμευση.
    4. Προσπαθούμε να βρούμε μια εναρκτήρια συμβολοσειρά στο μοτίβο μας.
3. Αν έχουμε βρει μια εναρκτήρια συμβολοσειρά, την χρησιμοποιούμε και σταματάμε.
4. Αν έχουμε βρει ένα δέντρο συμβολοσειρών, και μπορούμε να πραγματοποιήσουμε διανυσματοποιημένη αναζήτηση του εναρκτήριου χαρακτήρα (βλ. παρακάτω), δημιουργούμε ένα αντικείμενο `MultiStringMatcher` από το δέντρο -το οποίο κατά την κατασκευή θα θέσει τις τιμές για τον Aho-Corasick-, το χρησιμοποιούμε για τη συντόμευση πολλαπλών εναρκτήριων συμβολοσειρών, και σταματάμε.
5. Προσπαθούμε να βρούμε αν μπορούμε να χρησιμοποιήσουμε τις υπόλοιπες συντομεύσεις.
6. Αν δεν βρήκαμε μέχρι στιγμής κάποια συντόμευση, ή αυτή που βρήκαμε δεν είναι διανυσματοποιημένη, και είχαμε βρει προηγουμένως ένα δέντρο συμβολοσειρών, το χρησιμοποιούμε με τον τρόπο που περιγράφεται στο βήμα 4.

Ο κώδικας επιλογής της συντόμευσης βρίσκεται [στον δημιουργό της κλάσης `RegexFindOptimizations`](https://github.com/teo-tsirpanis/dotnet-runtime/blob/752473231ee952db44223f698ddd2d2af5599aa7/src/libraries/System.Text.RegularExpressions/src/System/Text/RegularExpressions/RegexFindOptimizations.cs#L18-L226). Το βήμα 2 υλοποιείται στην μέθοδο [`RegexPrefixAnalyzer.CreatePrefixMatcher`](https://github.com/teo-tsirpanis/dotnet-runtime/blob/752473231ee952db44223f698ddd2d2af5599aa7/src/libraries/System.Text.RegularExpressions/src/System/Text/RegularExpressions/RegexPrefixAnalyzer.cs#L14-L97).

## Τρέχουσες Βελτιστοποιήσεις

Χρησιμοποιούμε τα ακόλουθα τεχνάσματα για να βελτιστοποιήσουμε τις επιδόσεις της δημιουργίας του δέντρου και της αναζήτησης:

* Αναφερθήκαμε πριν σε διανυσματοποιημένη αναζήτηση του πρώτου χαρακτήρα στον αλγόριθμο Aho-Corasick. Αν στη ρίζα του δέντρου έχουμε το πολύ πέντε παιδιά, μπορούμε να χρησιμοποιήσουμε τη συνάρτηση `IndexOfAny` που είδαμε νωρίτερα, και να βρούμε με διανυσματοποιημένο τρόπο την θέση του πρώτου πιθανού χαρακτήρα. Αν δεν βρούμε κάποιον από τους πιθανούς πρώτους χαρακτήρες η αναζήτηση σταματάει.
* Επειδή όπως είπαμε, κατά την αναζήτηση λέξεων αν βρούμε κάποια λέξη σταματάμε κατευθείαν, μπορούμε να αγνοήσουμε λέξεις που κάποιο μη κενό τους πρόθημα ανήκει επίσης στις λέξεις που θέλουμε να βρούμε. Αυτήν την απαλοιφή την κάνουμε σε δύο βήματα κατά τη δημιουργία του δέντρου. Πρώτον με το που μαρκάρουμε κάποιον κόμβο ως κόμβο αντιστοίχισης αφαιρούμε όλα τα παιδιά του. Αυτό όμως δεν τα αφαιρεί από τη λίστα τον κόμβων που σημαίνει ότι σε μοτίβα όπως το $ab|abc$ μπορεί να προκύψουν απροσπέλαστοι κόμβοι, και γι' αυτό μετά την κατασκευή του δέντρου και πριν την ανάθεση των τιμών για τον Aho-Corasick τους διαγράφουμε ανατρέχοντας το δέντρο ξεκινώντας από τη ρίζα και σημειώνοντας τους προσπελάσιμους κόμβους.

## Μετρήσεις επιδόσεων

Οι επιδόσεις της χρήσης του Aho-Corasick μετρήθηκαν παίρνοντας [ένα τυχαίο βιβλίο του Project Gutenberg](https://www.gutenberg.org/ebooks/68148) και [μετρώντας τις εμφανίσεις των πρώτων `WordCount` πιο συνηθισμένων λέξεων της αγγλικής γλώσσας](https://gist.github.com/deekayen/4148741). Η τιμή στη στήλη `ToolChain` συμβολίζει τις μετρήσεις πριν (`\main\corerun.exe`) και μετά (`\pr\corerun.exe`) τις αλλαγές που κάναμε. Επίσης χρησιμοποιούμε και τη διερμηνευόμενη και τη μεταγλωττισμένη υλοποίηση. Οι μετρήσεις έγιναν με τη βοήθεια της βιβλιοθήκης [BenchmarkDotNet](https://benchmarkdotnet.org/articles/overview.html).

|     Method |         Toolchain | WordCount |  Options |        Mean |     Error |    StdDev | Ratio | RatioSD |
|----------- |------------------ |---------- |--------- |------------:|----------:|----------:|------:|--------:|
| **CountWords** | **\main\corerun.exe** |         **2** |     **None** |   **995.1 μs** |   **868.21 μs** |  **47.59 μs** |  **1.00** |    **0.00** |
| CountWords |   \pr\corerun.exe |         2 |     None |   670.7 μs |   236.26 μs |  12.95 μs |  0.67 |    0.03 |
|            |                   |           |          |            |             |           |       |         |
| **CountWords** | **\main\corerun.exe** |         **2** | **Compiled** |   **181.4 μs** |    **36.97 μs** |   **2.03 μs** |  **1.00** |    **0.00** |
| CountWords |   \pr\corerun.exe |         2 | Compiled |   248.1 μs |    34.42 μs |   1.89 μs |  1.37 |    0.03 |
|            |                   |           |          |            |             |           |       |         |
| **CountWords** | **\main\corerun.exe** |         **3** |     **None** | **1,225.2 μs** | **1,193.82 μs** |  **65.44 μs** |  **1.00** |    **0.00** |
| CountWords |   \pr\corerun.exe |         3 |     None |   797.4 μs |   630.72 μs |  34.57 μs |  0.65 |    0.03 |
|            |                   |           |          |            |             |           |       |         |
| **CountWords** | **\main\corerun.exe** |         **3** | **Compiled** |   **288.4 μs** |   **117.19 μs** |   **6.42 μs** |  **1.00** |    **0.00** |
| CountWords |   \pr\corerun.exe |         3 | Compiled |   261.5 μs |   119.35 μs |   6.54 μs |  0.91 |    0.01 |
|            |                   |           |          |            |             |           |       |         |
| **CountWords** | **\main\corerun.exe** |         **5** |     **None** | **2,075.1 μs** | **2,072.61 μs** | **113.61 μs** |  **1.00** |    **0.00** |
| CountWords |   \pr\corerun.exe |         5 |     None | 1,652.8 μs |   952.66 μs |  52.22 μs |  0.80 |    0.07 |
|            |                   |           |          |            |             |           |       |         |
| **CountWords** | **\main\corerun.exe** |         **5** | **Compiled** |   **609.5 μs** |   **773.25 μs** |  **42.38 μs** |  **1.00** |    **0.00** |
| CountWords |   \pr\corerun.exe |         5 | Compiled |   532.8 μs |    50.28 μs |   2.76 μs |  0.88 |    0.07 |
|            |                   |           |          |             |           |           |             |       |         |
| **CountWords** | **\main\corerun.exe** |        **10** |     **None** |  **3,076.6 μs** |  **66.86 μs** | **192.91 μs** |  **1.00** |    **0.00** |
| CountWords |   \pr\corerun.exe |        10 |     None |  2,119.1 μs |  30.36 μs |  26.91 μs |  0.64 |    0.03 |
|            |                   |           |          |             |           |           |       |         |
| **CountWords** | **\main\corerun.exe** |        **10** | **Compiled** |    **770.6 μs** |  **12.76 μs** |  **11.94 μs** |  **1.00** |    **0.00** |
| CountWords |   \pr\corerun.exe |        10 | Compiled |    765.4 μs |   7.58 μs |   7.09 μs |  0.99 |    0.02 |
|            |                   |           |          |             |           |           |       |         |
| **CountWords** | **\main\corerun.exe** |        **25** |     **None** |  **5,405.6 μs** | **106.22 μs** | **104.32 μs** |  **1.00** |    **0.00** |
| CountWords |   \pr\corerun.exe |        25 |     None |  3,135.8 μs |  61.30 μs |  51.19 μs |  0.58 |    0.01 |
|            |                   |           |          |             |           |           |       |         |
| **CountWords** | **\main\corerun.exe** |        **25** | **Compiled** |  **1,136.8 μs** |  **15.11 μs** |  **14.13 μs** |  **1.00** |    **0.00** |
| CountWords |   \pr\corerun.exe |        25 | Compiled |    881.0 μs |  13.09 μs |  12.24 μs |  0.78 |    0.01 |
|            |                   |           |          |             |           |           |       |         |
| **CountWords** | **\main\corerun.exe** |        **50** |     **None** | **11,919.2 μs** | **216.99 μs** | **181.20 μs** |  **1.00** |    **0.00** |
| CountWords |   \pr\corerun.exe |        50 |     None |  3,970.2 μs |  78.87 μs | 153.82 μs |  0.34 |    0.01 |
|            |                   |           |          |             |           |           |       |         |
| **CountWords** | **\main\corerun.exe** |        **50** | **Compiled** |  **1,605.9 μs** |  **31.25 μs** |  **29.24 μs** |  **1.00** |    **0.00** |
| CountWords |   \pr\corerun.exe |        50 | Compiled |  1,211.6 μs |  17.38 μs |  16.26 μs |  0.75 |    0.02 |

> Η στήλη `Error` σημαίνει το μισό του 99.9% διαστήματος εμπιστοσύνης των μετρήσεων. Είναι μεγαλύτερη στις μικρές μετρήσεις επειδή χρησιμοποιήσαμε λίγες επαναλήψεις για εξοικονόμηση χρόνου· κανονικά τέτοια benchmarks διαρκούν αρκετά λεπτά.

Με πάνω από πενήντα λέξεις υπερβαίνουμε το ανώτατο όριο των κόμβων στο δέντρο και ο Aho-Corasick δεν χρησιμοποιείται.

Όμως, [περαιτέρω μετρήσεις από την ομάδα του .NET](https://github.com/dotnet/runtime/pull/71588#issuecomment-1192735980) αναδεικνύουν μια δραματική μείωση της απόδοσης σε case-insensitive μοτίβα όπως το `(?i)Sherlock`, το οποίο ανάγεται στο μοτίβο `[Ss][Hh][Ee][Rr][Ll][Oo][Cc][KkK]` (το τρίτο K είναι ο χαρακτήρας `U+212A Kelvin Sign`). Εδώ συναντάμε μια παθογένεια του αλγορίθμου. Δημιουργούμε ένα δέντρο που το πλήθος κόμβων του αυξάνεται εκθετικά, με όλους τους συνδυασμούς των κεφαλαίων-πεζών χαρακτήρων της λέξης `Sherlock`, που στην ουσία αναπαριστούν την ίδια λέξη, ενώ θα μπορούσαμε να χρησιμοποιήσουμε κάποια πολύ πιο αποδοτική συντόμευση όπως των συνόλων σε σταθερή απόσταση που διαλέγει το .NET.

## Πιθανές μελλοντικές βελτιστοποιήσεις

Μια άμεση λύση για να φτιάξουμε την παραπάνω παθογενή κατάσταση είναι να τροποποιήσουμε τον κανόνα επιλογής 2.1. προσθέτοντας την περίπτωση "το μοτίβο δεν περιέχει μια δομή εναλλαγής στο εναρκτήριο σταθερό του τμήμα", και μοτίβα όπως το `(?i)Sherlock` θα αποκλειστούν (τα σύνολα αναπαρίστανται στο .NET διαφορετικά από τις δομές εναλλαγής).

Κάτι άλλο που μπορούμε να κάνουμε και θα βοηθούσε τέτοιες περιπτώσεις είναι μετά την ανάθεση τιμών για τον Aho-Corasick να πραγματοποιήσουμε μια απαλοιφή των ισοδύναμων κόμβων του δέντρου χρησιμοποιώντας μια παραλλαγή του [θεωρήματος Myhill-Nerode](https://www.geeksforgeeks.org/minimization-of-dfa-using-myhill-nerode-theorem/). Εφαρμόζοντάς το στο παραπάνω παράδειγμα θα είχαμε μόνο εννιά κόμβους -την ρίζα και έναν για κάθε γράμμα της λέξης `Sherlock`- και μπορούμε να πάμε από τον έναν κόμβο στον άλλον και με τον κεφαλαίο και με τον πεζό χαρακτήρα. Ένα πρόβλημα με αυτό είναι ότι αν έχουμε πολλές λέξεις του ίδιου μήκους, θα υπάρχει μόνο ένας κόμβος αντιστοίχισης, και το κατώτατο όριο των κόμβων αντιστοίχισης θα απορρίψει το δέντρο. Η λύση σε αυτό είναι να ελέγξουμε το όριο πριν την απαλοιφή των ισοδύναμων κόμβων. Επίσης πρέπει να εξεταστεί η εφαρμοστικότητα του θεωρήματος Myhill-Nerode -που χρησιμοποιείται συνήθως σε πεπερασμένα αυτόματα- σε δέντρα συμβολοσειρών όπως τα δικά μας.

Μιλώντας για απαλοιφή, είπαμε πριν ότι μπορούμε να απαλείψουμε λέξεις που κάποιο μη κενό τους _πρόθημα_ ανήκει κι' αυτό στις λέξεις. Μπορούμε να επεκτείνουμε τον κανόνα και να απαλείψουμε λέξεις που κάποιο μη κενό τους _υποσύνολο_ ανήκει κι' αυτό στις λέξεις. Για παράδειγμα, αν θέλουμε να βρούμε τη λέξη `bc` δε χρειάζεται να βρούμε και τη λέξη `abcd`. Η πλήρης αφαίρεση της λέξης `abcd` από το δέντρο είναι πιο δύσκολη, αλλά κάτι πιο εύκολο που μπορούμε να κάνουμε είναι να την περικόψουμε στη λέξη `abc`. Όλες αυτές οι απαλοιφές μπορούν να γίνουν αποδοτικά και με μόνο μία αντιγραφή του δέντρου στον τελικό του προορισμό κατά τη διάρκεια ανάθεσης τιμών, αντί για πριν.

Ένα άλλο πρόβλημα που παρουσιάζεται είναι ότι το άνω όριο των κόμβων δεν επηρεάζεται από τις αποκοπές. Για παράδειγμα αν έχουμε ένα δέντρο με 128 κόμβους και μετά τις απαλοιφές πέσει στους 50, θα μπορούσαμε αν αφήναμε περισσότερους κόμβους να το φτάναμε πιο κοντά στο όριο μετά τις απαλοιφές. Δεν υπάρχει κάποια εύκολη λύση σε αυτό το πρόβλημα. Αν αφήναμε ένα πιο μεγάλο όριο για την κατασκευή του δέντρου και απορρίπταμε το δέντρο μετά την απαλοιφή των κόμβων αν δεν έπεφτε αρκετά το πλήθος τους, κινδυνεύουμε να μείνουμε χωρίς καθόλου δέντρο.

Εκτός από διανυσματοποιημένη αναζήτηση των πρώτων πιθανών χαρακτήρων του δέντρου, αν οι πρώτοι κόμβοι του δέντρου σχηματίζουν μια σταθερή συμβολοσειρά (όπως αν είχαμε τις λέξεις `abc` και `abd`), θα μπορούσαμε να ψάξουμε γρήγορα τη συμβολοσειρά `ab` με τη διανυσματοποιημένη συνάρτηση `IndexOf`, συνδυάζοντας τις συντομεύσεις μίας και πολλαπλών εναρκτήριων συμβολοσειρών, και ίσως απλοποιώντας τους κανόνες επιλογής μεταξύ των δύο.

Το χαρακτηριστικό στοιχείο του αλγορίθμου Aho-Corasick είναι οι τιμές συνδέσμου επιθήματος, που μας επιτρέπουν να συνεχίσουμε απερίσκεπτοι και να μη γυρίσουμε πίσω στο κείμενο εισόδου αν βρούμε έναν χαρακτήρα που δεν περιμέναμε. Αν όλοι ή σχεδόν όλοι οι κόμβοι του δέντρου ενός μοτίβου (όπως το `aaa|bbb`) έχουν για σύνδεσμο επιθήματος τη ρίζα, θα μπορούσαμε να δώσουμε στον Aho-Corasick μικρότερη προτεραιότητα ακόμη κι' αν η αναζήτηση του πρώτου χαρακτήρα είναι διανυσματοποιημένη.

Μπορούμε επίσης να απαλείψουμε και τους συνδέσμους επιθήματος. Στο μοτίβο `aaa|bbb`, αν είμαστε στον κόμβο `aa` και συναντήσουμε τον χαρακτήρα `b`, αντί να πάμε στη ρίζα και μετά στον κόμβο `b`, μπορούμε να κάνουμε inline τις μεταβάσεις της ρίζας στον κόμβο `aa` και να πάμε στον `b` κατευθείαν. Η κύρια ανησυχία με αυτό είναι η μεγέθυνση των ευρετηρίων μεταβάσεων των κόμβων και του παραγόμενου κώδικα. Μπορούμε να το αντιμετωπίσουμε θέτοντας ένα όριο στις μεταβάσεις που μπορεί να πάρει ένας κόμβος κατ' αυτόν τον τρόπο. [Κάτι τέτοιο μπορεί να κάνει το κιβώτιο `aho-corasick` της Rust.](https://docs.rs/aho-corasick/latest/aho_corasick/struct.AhoCorasickBuilder.html#method.dfa)

Οι παραπάνω βελτιστοποιήσεις είναι προγραμματισμένες να υλοποιηθούν σύντομα. Σε πιο μακροπρόθεσμο ορίζοντα θα μπορούσαμε να χρησιμοποιήσουμε πιο διανυσματοποιημένους αλγορίθμους αναζήτησης, όπως τον [Teddy](https://github.com/jneem/teddy). Η κυριότερη πρόκληση σε αυτό είναι ότι τα χαρακτηριστικά απόδοσης του Teddy πιθανότατα θα διαφέρουν από τον Aho-Croasick και πρέπει να βρούμε καινούργιους ευρετικούς κανόνες για να αποφασίσουμε πότε να χρησιμοποιηθεί ο Teddy και πότε ο σκέτος Aho-Corasick.

## Ενδεικτικός παραγόμενος κώδικας

Ακολουθεί τμήμα της εξόδου της υλοποίησης με παραγόμενο πηγαίο κώδικα, για το μοτίβο `abc|bad`, αν χρησιμοποιούταν ο Aho-Corasick (δεν θα χρησιμοποιηθεί στην πραγματικότητα επειδή έχουμε κάτω από πέντε λέξεις):

```csharp
/// <summary>Search <paramref name=\"inputSpan\"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
/// <param name="inputSpan">The text being scanned by the regular expression.</param>
/// <returns>true if a possible match was found; false if no more matches are possible.</returns>
private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
{
    int pos = base.runtextpos;
    // Any possible match is at least 3 characters.
    if (pos < inputSpan.Length - 3)
    {
        // The pattern starts with one of 2 literals. Search for all of them together using a trie data structure.
        // If none of them can be found, there's no match.
        char c;
        // We are using a simplified version of the Aho-Corasick algorithm.
        // Each of the 11 states of our trie corresponds to a word. The root
        // of the trie corresponds to the empty string. At each state we read
        // the next character and compare to see if it can lead to one of the
        // state's children. If it does not, we repeat the search with the
        // characters of another state called the "suffix link".
        // If the state we landed in represents a match, we go backwards by
        // the length of the word we matched, and report that position.

        // ""
        State0:
        // We can perform a vectorized search to quickly find characters we are interested in.
        // If we can't find any, the search fails.
        switch (inputSpan.Slice(pos).IndexOfAny('a', 'b'))
        {
            case -1: return false;
            case int firstCharPos:
                pos += firstCharPos;
                break;
        }

        if (pos >= inputSpan.Length) return false;
        c = inputSpan[pos++];

        State0_Fallback:
        switch (c)
        {
            case 'a': goto State1;
            case 'b': goto State4;
            // We are at the root state and didn't find a character.
            // We will restart the algorithm and read a new one.
            default: goto State0;
        }

        // "a"
        State1:
        if (pos >= inputSpan.Length) return false;
        c = inputSpan[pos++];

        State1_Fallback:
        switch (c)
        {
            case 'b': goto State2;
            default: goto State0_Fallback;
        }

        // "ab"
        State2:
        if (pos >= inputSpan.Length) return false;
        c = inputSpan[pos++];

        switch(c)
        {
            case 'c': goto State3;
            default: goto State4_Fallback;
        }

        // "abc"
        State3:
        pos -= 3;
        goto FoundMatch;

        // "b"
        State4:
        if (pos >= inputSpan.Length) return false;
        c = inputSpan[pos++];

        State4_Fallback:
        switch (c)
        {
            case 'a': goto State5;
            default: goto State0_Fallback;
        }

        // "ba"
        State5:
        if (pos >= inputSpan.Length) return false;
        c = inputSpan[pos++];

        switch(c)
        {
            case 'd': goto State6;
            default: goto State1_Fallback;
        }

        // "bad"
        State6:
        pos -= 3;
        goto FoundMatch;

        FoundMatch:
        base.runtextpos = pos;
        return true;
    }
}
```

## Εκτιμώμενη κυκλοφορία

Για την ενσωμάτωση του Aho-Corasick στο .NET έχει υποβληθεί το Pull Request [#71588](https://github.com/dotnet/runtime/pull/71588) στο αποθετήριο `dotnet/runtime` (την στιγμή που γράφτηκε η αναφορά το Pull Request είναι κλειστό αλλά προσωρινά). Λόγω των προαναφερθέντων επιδεινώσεων στην απόδοση case-insensitive μοτίβων η αποδοχή του θα καθυστερήσει, και αναμένεται να κυκλοφορήσει με το .NET 8, του οποίου η πρώτη έκδοση προεπισκόπησης θα κυκλοφορήσει τον Φεβρουάριο του 2023, και η τελική έκδοση τον Νοέμβριο του 2023.

## Ευχαριστίες

Από την ομάδα του .NET θα ήθελα να ευχαριστήσω τον [Dan Moseley](https://github.com/danmoseley) που με προέτρεψε να ασχοληθώ με αυτό και τον [Stephen Toub](https://github.com/stephentoub) για το review του Pull Request. Επίσης ευχαριστώ και τον [Andrew Gallant](https://github.com/BurntSushi) για την δημιουργία του κιβωτίου `aho-corasick` στην Rust που με βοήθησε να καταλάβω τον αλγόριθμο, και για κάποιες πολύτιμες συμβουλές του.
