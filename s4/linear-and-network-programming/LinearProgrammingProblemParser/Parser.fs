module LinearProgrammingProblemParser.Parser

open System.Globalization
open Farkle
open Farkle.Builder
open Farkle.Builder.Regex
open LinearProgrammingProblemParser.DomainTypes
open System

let inline private curry f x1 x2 = f(x1, x2)

// Αυτό είναι ένα αντικείμενο τύπου DesigntimeFarkle<LPP>.
// Συμβολίζει μια γραμματική που θα "δώσει" αντικείμενα τύπου LPP.
// Μπορεί να είναι ένα τερματικό ή ένα μη-τερματικό, δε χρειάζεται
// να ξέρουμε. Όπως θα δούμε, ένα DesigntimeFarkle αποτελείται από μικρότερα
// τέτοια αντικείμενα, που ενωμένα, συνθέτουν πιο μεγάλες γραμματικές.
let designtime =
    // Ξεκινάμε να φτιάξουμε το τερματικό για τα νούμερα.
    // Τα τερματικά ορίζονται με κανονικές εκφράσεις.
    let number: DesigntimeFarkle<Number> =
        // Αυτή είναι μια κανονική έκφραση που αναγνωρίζει τουλάχιστον ένα ψηφίο.
        // Οι κανονικές εκφράσεις μπορούν να συνθέσουν μεγαλύτερες, όπως και τα
        // DesigntimeFarkle. Πρέπει να είμαστε πιο συγκεκριμένοι με το PredefinedSets.Number,
        // γιατί το σκέτο Number το ορίσαμε ήδη στον κώδικά μας.
        let atLeastOneNumber = chars PredefinedSets.Number |> atLeast 1
        // Η συνάρτηση concat επιστρέφει μια κανονική έκφραση που αποτελείται από
        // την συνένωση (concatenation) άλλων κανονικών εκφράσεων.
        concat [
            atLeastOneNumber

            // Ο τελεστής a <&> b είναι μια συντομογραφία του concat [a; b].
            optional (char '.' <&> atLeastOneNumber)

            [chars "e"; chars "+-" |> optional; atLeastOneNumber]
            |> concat
            |> optional
        // Η συνάρτηση terminal δημιουργεί ένα DesigntimeFarkle που
        // αντιπροσωπεύει ένα τερματικό. Δέχεται το όνομά του (για περιγραφικούς σκοπούς,
        // δεν έχει πρακτική χρησιμότητα), την κανονική έκφραση που το ορίζει
        // και μια συνάρτηση η οποία δέχεται την θέση του στο κείμενο (η οποία
        // δεν χρησιμοποιείται) και τους χαρακτήρες που το αποτελούν,
        // και επιστρέφει ένα αντικείμενο της αρεσκίας μας.
        // Στην συγκεκριμένη περίπτωση, όπου συναντήσει ένα τερματικό τύπου
        // Number, θα μετατρέψει τους χαρακτήρες του σε έναν δεκαδικό αριθμό.
        // Το T χρειάζεται για λόγους που οφείλονται σε περιορισμούς του συστήματος.
        // Χωρίς τη δεύτερη παράμετρο στην Number.Parse, οι τελείες δε θα διαχώριζαν
        // το κλασματικό μέρος στους υπολογιστές που είναι στα Ελληνικά.
        ] |> terminal "Number" (T(fun _ data -> Number.Parse(data, provider = NumberFormatInfo.InvariantInfo)))
    // Το ST είναι τύπου DesigntimeFarkle, χωρίς κάποια παράμετρο.
    // Δε μας ενδιαφέρει ποια ακριβώς λέξη χρησιμοποιήθηκε, οπότε
    // το αντικείμενο αυτό δε "δίνει" τίποτα.
    let ST =
        [
            string "st"
            string "s.t."
            // Στο "subject to" δεν χρειάζεται να έχουμε μόνο ένα κενό
            // ανάμεσα στις λέξεις. Επίσης μπορούμε να γράψουμε Whitespace
            // αντί για PredefinedSets.Whitespace, για ευκολία.
            string "subject" <&> atLeast 1 (chars Whitespace) <&> string "to"
        ]
        // Η συνάρτηση choice επιστρέφει μια κανονική έκφραση που αποτελείται από
        // την εναλλαγή (alternation) άλλων κανονικών εκφράσεων.
        |> choice
        // Επειδή είπαμε πως δε μας νοιάζει το περιεχόμενο του τερματικού
        // αυτού, θα χρησιμοποιήσουμε τη συνάρτηση terminalU (το U σημαίνει untyped)
        // η οποία δε ζητάει μια συνάρτηση όπως η terminal.
        |> terminalU "ST"
    let X =
        // Μπορεί να υπάρχει κενός χαρακτήρας μεταξύ του 'x' και του αριθμού.
        // Η συνάρτηση star εφαρμόζει το αστέρι του Kleene σε μια κανονική
        // έκφραση (καμία ή πολλές επαναλήψεις, ισοδύναμο με το atLeast 0).
        char 'x' <&> (star <| chars Whitespace) <&> (atLeast 1 <| chars PredefinedSets.Number)
        // Θα κόψουμε τον πρώτο χαρακτήρα (το x) και θα μετατρέψουμε
        // τους υπόλοιπους χαρακτήρες σε έναν ακέραιο, που θα τον
        // "τυλίξουμε" σε ένα αντικείμενο τύπου X. Η ενσωματομένη συνάρτηση
        // Int32.Parse αγνοεί τυχόν κενούς χαρακτήρες στην αρχή.
        |> terminal "X" (T(fun _ data -> Int32.Parse(data.Slice(1)) |> X))

    // Πάμε τώρα στα μη-τερματικά.
    let expression =
        let mkVariable isFirstVariable name =
            // Ο τελεστής ||= δημιουργεί ένα DesigntimeFarkle που αντιπροσωπεύει
            // ένα μη-τερματικό. Δέχεται το όνομά του, και τις παραγωγές που το αποτελούν.
            // Οι παραγωγές έχουν και μια συνάρτηση η οποία μετατρέπει τα επιμέρους
            // μέλη της σε ένα πιο σύνθετο αντικείμενο. Προφανώς όλες οι παραγωγές πρέπει να
            // επιστρέφουν αντικείμενα του ίδιου τύπου. Αυτό ελέγχεται κατά τη μεταγλώττιση.
            name ||= [
                // Η πρώτη μεταβλητή διαφοροποιείται ελάχιστα από τις
                // υπόλοιπες. Μπορούμε να εξοικονομήσουμε λίγο κώδικα.
                if isFirstVariable then
                    // Ο τελεστής !@ ξεκινάει την δημιουργία μιας παραγωγής
                    // της οποίας το πρώτο μέλος μας ενδιαφέρει.
                    // Ο τελεστής .>>. προσθέτει στην παραγωγή ένα ακόμα μέλος που μας ενδιαφέρει.
                    // Ο τελεστής => τελειώνει τη δημιουργία της παραγωγής.
                    // Δέχεται μια συνάρτηση που μετατρέπει τα μέλη της παραγωγής που μας
                    // ενδιαφέρουν σε ένα αντικείμενο τύπου Variable, στην περίπτωσή μας.
                    !@ number .>>. X => (fun num x -> Variable(num, x))
                    !@             X => (fun     x -> Variable(1.0, x))
                // Ο τελεστής !& ξεκινάει την δημιοργία μιας παραγωγής της οποίας
                // το πρώτο μέλος είναι ένα κυριολέκτημα (literal). Δε μας ενδιαφέρει
                // το περιεχόμενό του, πάντα το ίδιο θα είναι σε κάθε παραγωγή.
                !& "+" .>>. number .>>. X => (fun num x -> Variable( num, x))
                !& "-" .>>. number .>>. X => (fun num x -> Variable(-num, x))
                !& "+"             .>>. X => (fun     x -> Variable( 1.0, x))
                !& "-"             .>>. X => (fun     x -> Variable(-1.0, x))
            ]
        let firstVariable = mkVariable true  "First Variable"
        let moreVariables = mkVariable false "More Variables"

        "Expression" ||= [
            // Μια έκφραση θσ έχει σίγουρα μια μεταβλητή,
            // και μετά από αυτήν μπορεί να έχει περισσότερες.
            // Η συνάρτηση many επιστρέφει ένα μη-τερματικό που
            // αποτελείται από καμία ή πολλές επαναλήψεις του δοθέντος
            // DesigntimeFarkle. Ο τύπος list είναι συνδεδεμένη λίστα.
            // Στοιχεία στην κορυφή της μπορούν να μπουν σε χρόνο O(1).
            !@ firstVariable .>>. many moreVariables => (fun x xs -> x :: xs |> Expression)
        ]

    let objective = "Objective" ||= [
        !& "min" .>>. expression => Minimize
        !& "max" .>>. expression => Maximize
    ]

    let signedNumber = "Signed Number" ||= [
        // Η συνάρτηση id επιστρέφει το όρισμά της χωρίς να το αλλάξει.
        !@          number => id
        !& "+" .>>. number => id
        // Ο τελεστής ~- είναι συντομογραφία του τελεστή άρνησης (negation).
        !& "-" .>>. number => (~-)
    ]

    let constraints =
        "Constraint" ||= [
            // Ο τελεστής .>> προσθέτει στην παραγωγή ένα μέλος που το περιεχόμενό
            // του δε μας ενδιαφέρει. Μπορεί να είναι DesigntimeFarkle ή κυριολέκτημα.
            // Η συνάρτηση curry που την ορίσαμε πιο πριν μπορούμε να αποφύγουμε
            // το πιο φλύαρο (fun exp v -> Constraint.Equal(exp, v)).
            !@ expression .>> "="  .>>. signedNumber => (curry Constraint.Equal)
            !@ expression .>> "<=" .>>. signedNumber => (curry Constraint.LessThanOrEqual)
            !@ expression .>> ">=" .>>. signedNumber => (curry Constraint.GreaterThanOrEqual)
        // Η συνάρτηση many1 είναι σαν την many, αλλά πρέπει να υπάρχει
        // τουλάχιστον μία επανάληψη· δεν έχει νόημα πρόβλημα χωρίς περιορισμούς.
        ] |> many1

    // Ο τελεστής |||= δημιουργεί ένα μη-τερματικό που
    // το περιεχόμενό του δε μας ενδιαφέρει. Οι παραγωγές κανονικά συντάσσονται
    // με έναν άλλο τρόπο, αλλά στην περίπτωση αυτή, τυχαίνει να μπορούμε
    // να τις συντάξουμε όπως και πριν, χωρίς τον τελεστή =>.
    let endMaybe = "End Maybe" |||= [
        !& "end"
        // Το empty δηλώνει μια παραγωγή που δε θα έχει καθόλου μέλη.
        // Μη ξεχνάμε ότι το "end" στο τέλος είναι προαιρετικό.
        // Στην πραγματικότητα, τελεστές όπως ο `!@ x`
        // είναι συντομογραφίες του `empty .>>. x`.
        empty
    ]

    // Φτιάχνουμε τώρα το εναρκτήριο μη-τερματικό της γραμματικής μας.
    // Παίρνουμε την αντικειμενική συνάρτηση και τους περιορισμούς,
    // και δημιουργούμε το αντικείμενο τύπου LPP.
    "Linear Programming Problem" ||= [
        !@ objective .>> ST .>>. constraints .>> endMaybe => (fun o c ->
            {Objective = o; Constraints = c})
    ]
    // Προσθέτουμε και τα σχόλια, και επιστρέφουμε το τελικό DesigntimeFarkle.
    // Από προεπιλογή, η γραμματική είναι case-insensitive και αγνωεί τους
    // χαρακτήρες διαστήματος (κενό, tab, carriage return και line feed)
    // μεταξύ των τερματικών.
    |> DesigntimeFarkle.addLineComment "!"
    // Η παρακάτω συνάρτηση μαρκάρει το DesigntimeFarkle ότι μπορεί να
    // προμεταγλωττιστεί. Ο compiler θα το ανακαλύψει κατά τη μεταγλώττιση
    // του προγράμματος, και η κατασκευή του RuntimeFarkle από κάτω θα πάρει
    // σημαντικά λιγότερο χρόνο.
    |> fun x -> x.MarkForPrecompile typeof<LPP>.Assembly

// Το runtime είναι τύπου RuntimeFarkle<LPP>.
// Περιέχει τους πίνακες για την λεκτική και τη συντακτική ανάλυση
// Δε μπορεί να αποτελέσει μέρος μιας άλλης γραμματικής, σε αντίθεση
// με τα DesigntimeFarkle, τα οποία όμως δε μπορούν να χρησιμοποιηθούν
// από τον parser. Επειδή η δημιουργία των πινάκων αυτών είναι υπολογιστικά
// δαπανηρή, υπάρχει η διάκριση μεταξύ των DesigntimeFarkle και RuntimeFarkle.
// Η συνάρτηση RuntimeFarkle.build επιτρέπει την μονόδρομη μετατροπή από
// τον πρώτο στον δεύτερο τύπο όπου χρειάζεται. Αν υπάρχει κάποιο πρόβλημα με
// τη γραμματική, το RuntimeFarkle θα δημιουργηθεί παρ' όλα αυτά, μόνο
// που η χρήση του θα αποτυχαίνει πάντα.
let runtime = RuntimeFarkle.buildPrecompiled designtime
