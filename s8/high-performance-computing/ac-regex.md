# Χρήση του αλγορίθμου Aho-Corasick στη βιβλιοθήκη κανονικών εκφράσεων του .NET.

### Τσιρπάνης Θεόδωρος `dai19090`

## Εισαγωγή

### Ο αλγόριθμος Aho-Corasick

Ο [αλγόριθμος Aho-Corasick](https://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_algorithm) είναι ένας αλγόριθμος αναζήτησης κειμένου που εφευρέθηκε από τους Alfred V. Aho και Margaret J. Corasick το 1975. Δέχεται σαν είσοδο ένα σύνολο συμβολοσειρών (τις _λέξεις_), το προεπεξεργάζεται, και δημιουργεί μια μηχανή καταστάσεων βασισμένη σε ένα δέντρο συμβολισειρών (_trie_), με την οποία μπορεί σε αυθαίρετο κείμενο να βρει παρουσίες μίας εκ των λέξεων.

Για την λειτουργία του αλγορίθμου, κάθε κόμβος του δέντρου επαυξάνεται με τρεις τιμές, που αντιστοιχούν σε κάποιον κόμβο του δέντρου:

* Κάθε κόμβος έχει μια δυαδική τιμή που προσδιορίζει αν η συμβολοσειρά που του αντιστοιχεί ανήκει στις λέξεις που θέλουμε να βρούμε.
* Ο _σύνδεσμος επιθήματος_ (suffix link) ενός κόμβου $A$ είναι ο κόμβος $B$ που αντιστοιχεί στο μεγαλύτερο επίθημα της συμβολοσειράς του $A$ που ανήκει στο δέντρο. Το επίθημα αυτό μπορεί να είναι η κενή συμβολοσειρά, η οποία αντιστοιχεί στη ρίζα του δέντρου. Εκτός από την ρίζα, ο σύνδεσμος επιθήματος ενός κόμβου δεν μπορεί να είναι ο ίδιος με τον εαυτό του.
* Ο _σύνδεσμος ευρετηρίου_ (dictionary link) ενός κόμβου $A$ είναι ο κόμβος $B$ που αντιστοιχεί στο μακρύτερο επίθημα της συμβολοσειράς του $A$ που ανήκει στο δέντρο και στις λέξεις που θέλουμε να βρούμε. Αν δεν υπάρχει, το επίθημα αυτό μπορεί να είναι η κενή συμβολοσειρά, η οποία αντιστοιχεί στη ρίζα του δέντρου. Εκτός από την ρίζα, ο σύνδεσμος ευρετηρίου ενός κόμβου δεν μπορεί να είναι ο ίδιος με τον εαυτό του.

Ο αλγόριθμος διαβάζει από την συμβολοσειρά εισόδου έναν χαρακτήρα ανά φορά, και διατηρεί μεταξύ των επαναλήψεων μια μεταβλητή που δηλώνει τον τωρινό κόμβο του δέντρου που βρίσκεται, ο οποίος είναι αρχικά η ρίζα του δέντρου.

Σε κάθε επανάληψη πραγματοποιούνται τα εξής, όπου $i$ η τρέχουσα θέση της συμβολοσειράς εισόδου (με τον πρώτο χαρακτήρα να είναι στη θέση $0$) και $c$ ο τρέχον χαρακτήρας της εισόδου:

1. Από τον τωρινό κόμβο του δέντρου ελέγχουμε αν υπάρχει μετάβαση μέσω του χαρακτήρα $c$ σε κάποιον κόμβο.
    * Αν υπάρχει, θέτουμε τον τωρινό κόμβο σε αυτόν που οδηγεί η μετάβαση, και πηγαίνουμε στο βήμα 2.
    * Αν δεν υπάρχει:
        * Αν ο τωρινός κόμβος είναι η ρίζα του δέντρου, πηγαίνουμε στο βήμα 2.
        * Αν δεν είναι, θέτουμε τον τωρινό κόμβο στον σύνδεσμο επιθήματός του, και επαναλαμβάνουμε το βήμα 1.
2. Από τον τωρινό κόμβο του δέντρου, ανατρέχουμε προς τα πίσω μέσω των συνδέσμων ευρετηρίου, μέχρι να φτάσουμε στη ρίζα του δέντρου. Για κάθε κόμβο $x$ που συναντάμε και που η συμβολοσειρά του ανήκει στις λέξεις που θέλουμε να βρούμε, κάνουμε τα εξής:
    * Έστω $matchPos = i + 1 - length(x)$ η θέση της λέξης που βρήκαμε, όπου `length(x)` το μήκος της συμβολοσειράς που αντιστοιχεί στον κόμβο $x$ (αν δεν το έχουμε κρατήσει κάπου, μπορούμε να το υπολογίσουμε εύκολα βρίσκοντας το ύψος του κόμβου στο δέντρο).
    * Δηλώνουμε με κάποιον τρόπο ότι έχουμε βρει τη λέξη που αντιστοιχεί στον κόμβο $x$, στη θέση $matchPos$.

### Η βιβλιοθήκη κανονικών εκφράσεων του .NET

Από την πρώτη του κυκλοφορία το 2002, το προγραμματιστικό περιβάλλον .NET προσφέρει μια πλούσια βιβλιοθήκη κανονικών εκφράσεων, η οποία βρίσκεται στο namespace `System.Text.RegularExpressions`. Τα τελευταία χρόνια υπέστη σημαντικές βελτιώσεις στις εκδόσεις [.NET 5](https://devblogs.microsoft.com/dotnet/regex-performance-improvements-in-net-5/) και [.NET 7](https://devblogs.microsoft.com/dotnet/regular-expression-improvements-in-dotnet-7/), το οποίο θα κυκλοφορήσει τον Νοέμβριο του 2022.

Η χρήση της βιβλιοθήκης ξεκινάει με την κλάση `Regex`. Δημιουργούμε ένα αντικείμενο αυτού του τύπου, δίνοντας στον δημιουργό το μοτίβο και [επιπλέον επιλογές](https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regexoptions?view=net-7.0), και το χρησιμοποιούμε για να κάνουμε αντιστοιχήσεις σε κείμενο.

Ακολουθεί ένα απλό παράδειγμα χρήσης, παρμένο από [την τεκμηρίωση της κλάσης](https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex?view=net-7.0#examples):

```csharp
using System;
using System.Text.RegularExpressions;

// Define a regular expression for repeated words.
Regex rx = new Regex(@"\b(?<word>\w+)\s+(\k<word>)\b",
    RegexOptions.Compiled | RegexOptions.IgnoreCase);

// Define a test string.
string text = "The the quick brown fox  fox jumps over the lazy dog dog.";

// Find matches.
MatchCollection matches = rx.Matches(text);

// Report the number of matches found.
Console.WriteLine($"{matches.Count} matches found in:\n   {text}");

// Report on each match.
foreach (Match match in matches)
{
    GroupCollection groups = match.Groups;
    Console.WriteLine($"'{groups["word"].Value}' repeated at positions {groups[0].Index} and {groups[1].Index}");
}

// The example produces the following output to the console:
//       3 matches found in:
//          The the quick brown fox  fox jumps over the lazy dog dog.
//       'The' repeated at positions 0 and 4
//       'fox' repeated at positions 20 and 25
//       'dog' repeated at positions 49 and 53
```

> Το παράδειγμα έχει τροποποιηθεί από αυτό της τεκμηρίωσης για να χρησιμοποιεί νέες λειτουργίες της γλώσσας. Οι διαφορές είναι ενδιαφέρουσες· [δεν υπάρχει `Main`](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/program-structure/top-level-statements), και χρησιμοποιούνται [interpolated strings](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated), [τα οποία έγιναν πιο αποδοτικά στο .NET 6](https://devblogs.microsoft.com/dotnet/string-interpolation-in-c-10-and-net-6/).

Κατά τη δημιουργία του αντικειμένου `Regex`, το μοτίβο υφίσταται συντακτική ανάλυση, και μετατρέπεται σε ένα συντακτικό δέντρο, το οποίο βελτιστοποιείται και περνιέται σε κάποια από τις υλοποιήσεις της βιβλιοθήκης που θα αναλάβει την αντιστοίχιση του κειμένου. Προσφέρονται τέσσερις υλοποιήσεις, εκ των οποίων οι δύο προστέθηκαν στο .NET 7:

* Η __διερμηνευόμενη__ υλοποίηση μετατρέπει το μοτίβο σε μια σειρά εντολών μιας απλής μηχανής στοίβας, που κατά την αντιστοίχιση εκτελούνται από έναν διερμηνέα. Είναι η προεπιλεγμένη υλοποίηση.
* Η __μεταγλωττισμένη__ υλοποίηση μετατρέπει το μοτίβο σε bytecode του .NET (ονομάζεται _IL_ από το Intermediate Language) το οποίο μεταγλωττίζεται σε native γλώσσα μηχανής από το JIT. Πληρώνοντας ένα υψηλότερο κόστος αρχικοποίησης, πετυχαίνουμε σημαντικά καλύτερες επιδόσεις από τη διερμηνευόμενη υλοποίηση. Χρησιμοποιείται περνώντας την επιλογή `RegexOptions.Compiled` κατά τη δημιουργία του αντικειμένου `Regex`. Στις πλατφόρμες που δεν υποστηρίζουν παραγωγή μεταγλωττισμένου δυναμικού κώδικα (όπως iOS και WebAssembly) χρησιμοποιείται η διερμηνευόμενη λειτουργία.
*
    Η υλοποίηση με __παραγόμενο πηγαίο κώδικα__ είναι καινούργια στο .NET 7 και χρησιμοποιεί επεκτάσεις του μεταγλωττιστή της C# που λέγονται [_γεννήτριες πηγαίου κώδικα_ (source generators)](https://docs.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/source-generators-overview). Ας δούμε πρώτα ένα παράδειγμα χρήσης της:

    ```csharp
    using System;
    using System.Text.RegularExpressions;

    Regex rx = MyRegex.GetMyRegex();

    // Define a test string.
    string text = "The the quick brown fox  fox jumps over the lazy dog dog.";

    // Find matches.
    int matches = rx.Count(text);

    // Report the number of matches found.
    Console.WriteLine($"{matches} matches found in:\n   {text}");

    internal static partial class MyRegex
    {
        // Define a regular expression for repeated words.
        [GeneratedRegex(@"\b(?<word>\w+)\s+(\k<word>)\b", RegexOptions.IgnoreCase)]
        public static partial Regex GetMyRegex();
    }
    ```

    Ορίζουμε τη μέθοδο `GetMyRegex` χωρίς υλοποίηση και με τη λέξη `partial`, που σημαίνει ότι η υλοποίησή της βρίσκεται σε κάποιο άλλο αρχείο, το οποίο θα το παράξει ο μεταγλωττιστής της C# όταν "χτίσουμε" το πρόγραμμα, και θα περιέχει εξειδικευμένο κώδικα σε C# για να αντιστοιχίσει το μοτίβο μας. Η χρήση του source generator προτείνεται σε κάθε περίπτωση όπου το μοτίβο είναι γνωστό κατά τη μεταγλώττιση, και με μόνο αρνητικό μια ελαφρά αύξηση του μεγέθους του μεταγλωττισμένου αρχείου, προσφέρει μια πληθώρα πλεονεκτημάτων:

    * Το κόστος αρχικοποίησης του αντικειμένου `Regex` εκμηδενίζεται. Δεν χρειάζεται όταν εκτελέσουμε το πρόγραμμα να αναλύσουμε το μοτίβο, αυτό έγινε όταν μεταγλωττίσαμε το πρόγραμμα!
        * Αυτό επίσης σημαίνει ότι τα σχετικά τμήματα της βιβλιοθήκης μπορούν να [περικοπούν](https://docs.microsoft.com/en-us/dotnet/core/deploying/trimming/trim-self-contained), μειώνοντας το μέγεθος της τελικής εφαρμογής.
    * Η απόδοση της αντιστοίχισης είναι ισάξια της μεταγλωττισμένης υλοποίησης (οι δύο υλοποιήσεις παράγουν ισοδύναμο κώδικα σε IL και C# αντίστοιχα), και χωρίς κανένα μειονέκτημα· επειδή δεν παράγεται κώδικας δυναμικά, μπορεί να χρησιμοποιηθεί οπουδήποτε υποστηρίζεται το .NET.
    * Επειδή μπορούμε να δούμε τον παραγόμενο κώδικα, μπορούμε να βάλουμε breakpoints και να τον εκσφαλματώσουμε για να διαγνώσουμε λάθη στο μοτίβο μας, ή να μάθουμε πώς λειτουργεί. Ο παραγόμενος κώδικας είναι επίσης σχολιασμένος, βοηθώντας μας στο δεύτερο.
* Η υλοποίηση __χωρίς οπισθοδρόμηση__ είναι επίσης καινούργια στο .NET 7, και εντελώς διαφορετική από τις άλλες δύο, βασιζόμενη στον [Symbolic Regex Matcher](https://www.microsoft.com/en-us/research/publication/symbolic-regex-matcher/), ένα ερευνητικό έργο της Microsoft Research που χρησιμοποιεί πεπερασμένα αυτόματα. Στόχος της είναι να αποφύγει τις λεγόμενες ["καταστροφικές οπισθοδρομήσεις" που οδηγούν σε εκθετικό χρόνο αντιστοίχισης και αποτελούν πηγή επιθέσεων άρνησης υπηρεσίας](https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS). Περιορίζοντας ορισμένες δυνατότητες των κανονικών εκφράσεων όπως τα backreferences (τα παραδείγματα πάνω δε μπορούν να λειτουργήσουν χωρίς οπισθοδρόμηση), η υλοποίηση αυτή εγγυάται γραμμικό χρόνο αντιστοίχισης για κάθε είσοδο. Χρησιμοποιείται περνώντας την επιλογή `RegexOptions.NonBacktracking` κατά τη δημιουργία του αντικειμένου `Regex`. Προς το παρόν δεν είναι συμβατή με τη μεταγλωττισμένη υλοποίηση ή τον source generator.

### Συντομεύσεις στην εύρεση πιθανών αντιστοιχίσεων

Επειδή η αντιστοίχιση μιας κανονικής έκφρασης μπορεί να είναι υπολογιστικά δαπανηρή, και για την αποφυγή περιττών υπολογισμών σε άσχετα σημεία του κειμένου, η βιβλιοθήκη μπορεί ανάλογα με το μοτίβο να πάρει κάποιες "συντομεύσεις" για να ψάξει γρήγορα μέσα στο κείμενο εισόδου για πιθανά σημεία που μπορούν να αποτελέσουν μια αντιστοίχιση, πριν μεταβεί στον ενδελεχή κύριο αλγόριθμο. Αυτή η λογική περιέχεται στην εσωτερική κλάση [`RegexFindOptimizations`](https://github.com/dotnet/runtime/blob/8a26f96b6d0e0c557be1f4a6d67e74391f566f3c/src/libraries/System.Text.RegularExpressions/src/System/Text/RegularExpressions/RegexFindOptimizations.cs), και οι διαφορετικές συντομεύσεις περιγράφονται στην απαρίθμηση [`FindNextStartingPositionMode`](https://github.com/dotnet/runtime/blob/8a26f96b6d0e0c557be1f4a6d67e74391f566f3c/src/libraries/System.Text.RegularExpressions/src/System/Text/RegularExpressions/RegexFindOptimizations.cs#L701-L753). Κάθε κανονική έκφραση μπορεί να χρησιμοποιήσει μόνο μια συντόμευση. Οι διερμηνευόμενες υλοποίησεις χρησιμοποιούν το αντικείμενο `RegexFindOptimizations`, και στις υλοποιήσεις με παραγόμενο κώδικα παράγεται εξειδικευμένος κώδικας για την συντόμευση.

Οι συντομεύσεις μπορούν να συνοψιστούν ως εξής, κατά φθίνουσα σειρά προτίμησης:

* __Anchors:__ Σε μοτίβα όπως το `^hello world`, ο χαρακτήρας `^` σημαίνει ότι το μοτίβο μπορεί να αντιστοιχιστεί μόνο στην αρχή του κειμένο εισόδου. Αυτό σημαίνει ότι αν έχουμε περάσει την αρχή, δεν υπάρχουν άλλες πιθανές αντιστοιχίσεις και μπορούμε να τελειώσουμε την αναζήτηση. Υπάρχουν συνολικά δέκα συντομεύσεις αυτού του τύπου, για τα διάφορα είδη anchors, και ανάλογα με το αν η αντιστοίχιση γίνεται από τα δεξιά προς τα αριστερά (με την επιλογή `RegexOptions.RightToLeft`). Επειδή αυτές οι συντομεύσεις εκτελούνται σε σταθερό χρόνο, επιλέγονται πάντα αν το μοτίβο περιέχει anchors.
* __Εναρκτήρια συμβολοσειρά:__ Mοτίβα όπως το `Tel: \d{10}` ξεκινούν με μια σταθερή συμβολοσειρά. Χρησιμοποιώντας την συνάρτηση [`IndexOf`](https://docs.microsoft.com/en-us/dotnet/api/system.memoryextensions.indexof) η οποία έχει μια διανυσματοποιημένη υλοποίηση, μπορούμε να ψάξουμε γρήγορα αυτήν την σταθερή συμβολοσειρά, και να μεταβούμε στον κύριο αλγόριθμο μόνο αν την βρούμε. Αν δεν υπάρχει, δεν υπάρχουν άλλες πιθανές αντιστοιχίσεις και μπορούμε να τελειώσουμε την αναζήτηση. Σε αυτήν την κατηγορία ανήκουν οι συντομεύσεις `LeadingString_LeftToRight`, `LeadingString_RightToLeft` και `LeadingChar_RightToLeft`.
*
    __Εναρκτήριο σύνολο:__ Για να ελέγξουν αν ένας χαρακτήρας ανήκει σε ένα σύνολο, οι υλοποιήσεις με παραγόμενο κώδικα μπορούν να παράξουν εξειδικευμένο κώδικα που είναι πολύ πιο αποδοτικός. Σε ένα απλό παράδειγμα, αν έχουμε ένα σύνολο όπως το `\d`, αν ο χαρακτήρας που θέλουμε να ελέγξουμε είναι ο `c`, αντί για `c is '0' or '1' or '2' or '3' or '4' or '5' or '6' or '7' or '8' or '9'` που θα κάνει δέκα συγκρίσεις, θα παράξουμε `(uint)(c - '0') <= (uint)('9' - '0')` που θα κάνει μία σύγκριση.

    Για να βρούμε μέσα σε μια συμβολοσειρά την πρώτη εμφάνιση ενός από κάποιους χαρακτήρες, το .NET προσφέρει τη συνάρτηση [`IndexOfAny`](https://docs.microsoft.com/en-us/dotnet/api/system.memoryextensions.indexofany?view=net-7.0#system-memoryextensions-indexofany-1(system-readonlyspan((-0))-system-readonlyspan((-0)))), η υλοποίηση της οποίας είναι διανυσματοποιημένη όταν οι χαρακτήρες που θέλουμε να βρούμε είναι το πολύ πέντε. Ανεξάρτητα της υλοποίησης που χρησιμοποιούμε, αν το μοτίβο μας ξεκινάει από ένα τέτοιο μικρό σύνολο, χρησιμοποιούμε την `IndexOfAny` για να βρούμε πιθανές αντιστοιχίσεις ακόμη πιο αποδοτικά. Αν το σύνολο είναι μεγαλύτερο είτε παράγουμε εξειδικευμένο κώδικα αν μπορούμε, είτε καταφεύγουμε σε πιο αργές μεθόδους. Αν δεν βρούμε κάποιον από τους χαρακτήρες του εναρκτήριου συνόλου, δεν υπάρχουν άλλες πιθανές αντιστοιχίσεις και μποορύμε να τελειώσουμε την αναζήτηση. Σε αυτήν την κατηγορία ανήκουν οι συντομεύσεις `LeadingSet_LeftToRight` και `LeadingSet_RightToLeft`.
* __Συμβολοσειρά σε σταθερή απόσταση:__ Το μοτίβο `[^ ]{4} [^ ]{4}` αντιστοιχίζει χαρακτήρες διαστήματος που περικλείονται από τέσσερις χαρακτήρες διαφορετικούς του διαστήματος. Το εναρκτήριο σύνολο του μοτίβου είναι πολύ μεγάλο οπότε δε μπορούμε να χρησιμοποιήσουμε την παραπάνω συντόμευση, αλλά αυτό που μπορούμε να κάνουμε είναι να βρούμε το διάστημα, και αν υπάρχει να γυρίσουμε τέσσερις χαρακτήρες πίσω, και να μεταβούμε στον κύριο αλγόριθμο. Αν δεν το βρούμε, δεν υπάρχουν άλλες πιθανές αντιστοιχίσεις και μποορύμε να τελειώσουμε την αναζήτηση. Σε αυτήν την κατηγορία ανήκουν οι συντομεύσεις `FixedDistanceChar_LeftToRight` και `FixedDistanceString_LeftToRight`.
* __Σύνολα σε σταθερές αποστάσεις:__ Το μοτίβο `\d{4} \d{4}` αντιστοιχίζει τέσσερα δεκαδικά ψηφία, έναν χαρακτήρα διαστήματος και άλλα τέσσερα δεκαδικά ψηφία. Εδώ μπορούμε να εκμεταλλευτούμε το εναρκτήριο σύνολο αλλά δεν είναι τόσο μικρό για διανυσματοποιημένη αναζήτηση. Θα χρησιμοποιήσουμε την παραπάνω συντόμευση και θα βρούμε γρήγορα τον χαρακτήρα διαστήματος, αλλά για να περιορίσουμε τα ψευδή θετικά, θα ελέγξουμε αν οι πρώτοι δύο χαρακτήρες της πιθανής αντιστοίχισης είναι δεκαδικά ψηφία, και στην αντίθετη περίπτωση θα ψάξουμε για τον επόμενο χαρακτήρα διαστήματος και θα επαναλάβουμε τη διαδικασία. Για λόγους εξοικονόμησης χρόνου χρησιμοποιούνται μέχρι τρία σύνολα· αν υπάρχουν περισσότερα επιλέγονται αυτά με τους πιο σπάνιους χαρακτήρες [βάσει ενός πίνακα συχνότητας που υπολογίστηκε από τα αρχεία C# του αποθετηρίου του περιβάλλοντος εκτέλεσης του .NET και τα 25 πιο δημοφιλή βιβλία του Project Gutenberg](https://github.com/dotnet/runtime/blob/347847265d0832def96a2ff4057029999ffc70b1/src/libraries/System.Text.RegularExpressions/src/System/Text/RegularExpressions/RegexPrefixAnalyzer.cs#L868-L944). Σε αυτήν την κατηγορία ανήκει η συντόμευση `FixedDistanceSets_LeftToRight`.
* __Συμβολοσειρά μετά από επανάληψη:__ Το μοτίβο `[1-9]*0` αντιστοιχίζει καμία ή πολλές επαναλήψεις των ψηφίων ένα έως εννιά, ακολοθυούμενα από το ψηφίο μηδέν. Θα μπορούσαμε να θέσουμε ως εναρκτήριο σύνολο το `[0-9]` αλλά  δεν θα το κάνουμε επειδή είναι πολύ μεγάλο για να διανυσματοποιηθεί η αναζήτηση. Αντ' αυτού θα ψάξουμε το μηδέν με τη διανυσματοποιημένη `IndexOf`, και αν το βρούμε θα γυρίσουμε προς τα πίσω μέχρι να βρούμε χαρακτήρα που δεν ανήκει στο `[1-9]`, και από εκεί θα μεταβούμε στον κύριο αλγόριθμο. Αν δε το βρούμε, δεν υπάρχουν άλλες πιθανές αντιστοιχίσεις και μπορούμε να τελειώσουμε την αναζήτηση. Σε αυτήν την κατηγορία αντιστοιχεί η συντόμευση `LiteralAfterLoop_LeftToRight`.
* __Τίποτα:__ Αν δεν ισχύουν οι συνθήκες για καμία από τις παραπάνω συντομεύσεις, προχωράμε κατευθείαν στον κύριο αλγόριθμο. Σε αυτήν την κατηγορία ανήκει η "συντόμευση" `NoSearch`.

## Τι προστέθηκε

Στην παραπάνω λίστα προσθέτουμε μια νέα κατηγορία συντομεύσεων:

* __Πολλαπλές εναρκτήριες συμβολοσειρές:__ Μοτίβα όπως το `monday|tuesday|wednesday|thursday|friday|saturday|sunday` ξεκινούν με μία από ένα πεπερασμένο σύνολο συμβολοσειρών. Μπορούμε να χρησιμοποιήσουμε τον αλγόριθμο Aho-Corasick για να βρούμε πιθανές αντιστοιχίσεις στο κείμενο εισόδου, με μεγαλύτερη ακρίβεια από μία σκέτη χρήση του εναρκτήριου συνόλου `[mtwfs]`. Σε αυτήν την κατηγορία ανήκει η συντόμευση `LeadingMultiString_LeftToRight`.

Το πρόβλημα της ενσωμάτωσης του αλγορίθμου Aho-Corasick μπορεί να διαιρεθεί σε τρία υποπροβλήματα, ταξινομημένα κατά αύξουσα σειρά δυσκολίας:

* Πρέπει να προσαρμώσουμε τον αλγόριθμο στις ανάγκες μας.
* Πρέπει να πάρουμε από το μοτίβο τις λέξεις που θα δώσουμε στον αλγόριθμο για να βρει.
* Πρέπει να αποφασίσουμε πότε συμφέρει να χρησιμοποιηθεί ο Aho-Corasick αντί για κάποια άλλη συντόμευση.

### Τροποποιήσεις στον αλγόριθμο Aho-Corasick

Ο αλγόριθμος Aho-Corasick που περιγράψαμε στην αρχή βρίσκει _όλες_ τις λέξεις στο κείμενο εισόδου, καθώς και _ποια_ από αυτές βρέθηκε κάθε φορά. Όμως οι απαιτήσεις μας για την γρήγορη εύρεση πιθανών αντιστοιχίσεων είναι μικρότερες. Πρώτον, σε κάθε εκτέλεση του αλγορίθμου θέλουμε να βρούμε μόνο την πρώτη λέξη μέσα στο κείμενο εισόδου και δεύτερον, δε μας ενδιαφέρει συγκεκριμένα ποια από τις λέξεις βρήκαμε. Με βάση αυτά μπορούμε να κάνουμε τις ακόλουθες τροποποιήσεις στον αρχικό αλγόριθμο.

*
    Κάθε κόμβος έχει μια τιμή που ονομάζεται _μήκος αντιστοίχισης_ και ορίζεται ως εξής:
    * Αν η συμβολοσειρά που αντιστοιχεί στον κόμβο ανήκει στις λέξεις που θέλουμε να βρούμε, το μήκος αντιστοίχισής της είναι ίσο με το μήκος της συμβολοσειράς αυτής.
    * Σε αντίθετη περίπτωση είναι ίσο με το μήκος της συμβολοσειράς που αντιστοιχεί στον σύνδεσμο ευρετηρίου του κόμβου.
* Η τιμή του συνδέσμου ευρετηρίου των κόμβων δεν είναι χρήσιμη για την αναζήτηση, ούτε είναι χρήσιμο το αν η συμβολοσειρά του κάθε κόμβου ανήκει στις λέξεις που θέλουμε να βρούμε.
*
    Το δεύτερο βήμα του αλγορίθμου εύρεσης λέξεων αντικαθίσταται ως εξής:
    > Έστω $matchLength$ η τιμή του μήκους αντιστοίχισης του τωρινού κόμβου. Αν $matchLength \ne 0$ σταματάμε την αναζήτηση αναφέροντας ότι βρήκαμε μια λέξη στη θέση $i + 1 - matchLength$.
* Επειδή με το που βρούμε μια λέξη σταματάμε, μπορούμε να περιορίσουμε τις λέξεις που θέλουμε να βρούμε, παραλείποντας αυτές στις οποίες θέλουμε να βρούμε ένα μη κενό πρόθημά τους. Για παράδειγμα αν θέλουμε να βρούμε τη λέξη `a`, δεν χρειάζεται να προσθέσουμε τη λέξη `ab`.

Η υλοποίηση του αλγορίθμου βρίσκεται στην κλάση [`MultiStringMatcher`](https://github.com/teo-tsirpanis/dotnet-runtime/blob/aho-corasick/src/libraries/System.Text.RegularExpressions/src/System/Text/RegularExpressions/MultiStringMatcher.cs). Οι διερμηνευόμενες υλοποιήσεις χρησιμοποιούν την κλάση κατευθείαν, ενώ για τις άλλες παράγεται εξειδικευμένος πηγαίος κώδικας ή IL για το κάθε δέντρο. Ενδεικτικός παραγόμενος πηγαίος κώδικας παρατίθεται στο τέλος της αναφοράς.

### Δημιουργία του δέντρου συμβολοσειρών

Το παράδειγμα που δείξαμε πριν με τις ημέρες της εβδομάδας ακολουθεί ένα μοτίβο της μορφής `a|b|c|d|e` από το οποίο μπορούμε εύκολα να εντοπίσουμε τις λέξεις που θέλουμε να προσθέσουμε στο δέντρο συμβολοσειρών. Όμως, υπάρχουν πολλά ακόμα πιθανά μοτίβα που θέλουμε να υποστηρίξουμε, και γι' αυτό χρειαζόμαστε έναν γενικό αναδρομικό αλγόριθμο.

Η γενική ιδέα του αλγορίθμου είναι ότι αφού δημιουργίσουμε τη ρίζα του δέντρου, διασχίζουμε το μοτίβο από αριστερά προς τα δεξιά, προσθέτοντας χαρακτήρες στους κόμβους μέχρι να φτάσουμε σε κάποιο μη σταθερό σημείο του μοτίβου, και λαμβάνοντας υπ' όψιν εναλλακτικά μονοπάτια που μπορούν να παρθούν. Σε κάθε βήμα του αλγόρίθμου κρατάμε κάποιους κόμβους "στο χέρι μας", τους οποίους θα αναπτύσσουμε προσθέτοντας σε αυτούς, τους χαρακτήρες που συναντάμε.

Για παράδειγμα, το μοτίβο `a(b|c)de*` αναλύεται ως εξής:

* Δημιουργούμε τη ρίζα, και τη βάζουμε στο χέρι μας.
* Συναντάμε τον χαρακτήρα `a` και προσθέτουμε στη ρίζα έναν νέο κόμβο που αντιστοιχεί στη συμβολοσειρά `a`, και τον κρατάμε στο χέρι μας.
* Συναντάμε τη δομή `b|c`, και εκτελώντας αναδρομικά τον αλγόριθμο, προσθέτουμε μετά τον κόμβο του `a`, το `b` στη μία διακλάδωση και το `c` στην άλλη, αφήνοντας στο χέρι μας τους κόμβους `ab` και `ac` αντίστοιχα. Συγχωνεύουμε τα χέρια των διακλαδώσεων, και κρατάμε στο χέρι μας και τον `ab` και τον `ac`.
* Συναντάμε το `d`, και το προσθέτουμε στους κόμβους `ab` και `ac`. Κρατάμε στο χέρι μας τους κόμβους `abd` και `acd`.
* Συναντάμε το `e*` αλλά δε μπορούμε να προσθέσουμε κάποιον χαρακτήρα, επειδή αντιστοιχίζουμε από μηδέν μέχρι άπειρες εμφανίσεις του `e` και δεν υπάρχει κάποιο σταθερό μέρος στην έκφραση, που σημαίνει ότι σταματάμε την επανάληψη εδώ, και μαρκάρουμε τους κόμβους που κρατάμε στο χέρι μας ως κόμβους αντιστοίχισης. Το δέντρο μας θα αντιστοιχίζει τις συμβολοσειρές `abd` και `acd`.

Αν ένας κόμβος έχει ήδη μια μετάβαση με κάποιον χαρακτήρα, δεν θα δημιουργήσουμε έναν καινούργιο, αλλά θα πάρουμε τον υπάρχοντα κόμβο και θα τον κρατήσουμε στο χέρι μας. Κάτι τέτοιο συμβαίνει στο μοτίβο `aa|ab`, όταν πάμε στη δεύτερη διακλάδωση.

Η ισχύς του αλγορίθμου αναδεικνύεται στην περίπτωση που η ροή "κόβεται" σε κάποιες αλλά όχι όλες τις διακλαδώσεις. Ένα παράδειγμα είναι το μοτίβο $a(b|c|d+)e$. Προσθέτουμε το $a$ στη ρίζα κανονικά, προσθέτουμε το $ab$ και το $ac$ όπως στο προηγούμενο παράδειγμα, αλλά φτάνοντας στο $d+$ (που είναι ισοδύναμο με το $dd*$), προσθέτουμε το $ad$, αλλά δε μπορούμε να συνεχίσουμε μετά το $d*$. Αυτό που κάνουμε είναι να μαρκάρουμε το $ad$ ως κόμβο αντιστοίχισης, και να συνεχίσουμε κρατώντας στο χέρι μας μόνο τους $ab$ και $ac$, προσθέτοντας σε αυτούς το $e$. Το δέντρο μας θα αντιστοιχίζει τις συμβολοσειρές $abe$, $ace$ και $ad$.

> Γενικεύοντας, το .NET αναπαριστά τους ποσοδείκτες ως δομές επανάληψης. Για παράδειγμα το $x*$ αναπαρίσταται ως $x\{0,∞\}$, και το $x+$ ως $x\{1,∞\}$. Αν ο αλγόριθμός μας συναντήσει μια δομή επανάληψης της μορφής $x\{m,n\}$, θα προσθέσει το $x$ (το οποίο δεν χρειάζεται να είναι χαρακτήρας αλλά μια αυθαίρετα σύνθετη έκφραση) $m$ φορές, και θα συνεχίσει μόνο αν $m = n$.
>
> Αν $m \ne n$, δεν αναπτύσσουμε την επανάληψη (για παράδειγμα μετατρέποντας το $a\{2,4\}$ σε $aa|aaa|aaaa$) επειδή δεν θέλουμε να παράγουμε υπερβολικά πολλούς κόμβους, με μόνη εξαίρεση την περίπτωση όπου η έκφραση είναι της μορφής $x\{0,1\}$, που αντιστοιχεί στο μοτίβο $x?$ και δεν βρίσκεται στο τέλος. Αυτό μας επιτρέπει να χειριστούμε μοτίβα όπως το $a?bc$ και να πάρουμε τις λέξεις $abc$ και $bc$.

Υπάρχει επίσης περίπτωση να μαρκαριστεί ως κόμβος αντιστοίχισης _η ρίζα_, όπως συμβαίνει στο μοτίβο $(a|b|c*)$. Η τρίτη διακλάδωση δε μπορεί να συνεχίσει, στο χέρι μας κρατάμε τη ρίζα και τη μαρκάρουμε. Αν συμβεί αυτό, το δέντρο είναι άχρηστο και ο αλγόριθμος Aho-Corasick δε μπορεί να χρησιμοποιηθεί. Υπάρχουν δύο εξηγήσεις γι' αυτό, μία από την οπτική του δέντρου και μία από την οπτική του μοτίβου:

* Αν η ρίζα είναι κόμβος αντιστοίχισης, αυτό σημαίνει ότι στις λέξεις του Aho-Corasick ανήκει η κενή συμβολοσειρά, και επειδή σταματάμε με το που βρούμε μια λέξη, βρίσκουμε την κενή συμβολοσειρά στην αρχή του κειμένου, και η αναζήτηση δεν έχει νόημα!
* Όταν ο αλγόριθμός μας συναντήσει μια δομή εναλλαγής, πρέπει να λάβει υπ' όψιν είτε _όλες_ τις διακλαδώσεις είτε _καμία_. Δε θα μπορούσαμε για παράδειγμα να αγνοήσουμε την τρίτη διακλάδωση επειδή το δέντρο θα ήταν λάθος επειδή κατά την αντιστοίχιση του μοτίβου θα προσπερνούσε τυχόν εμφανίσεις του χαρακτήρα $c$. Γενικότερα, ο αλγόριθμός μας βρίσκει ένα εναρκτήριο σταθερό σημείο τμήμα στο μοτίβο. Αν στις λέξεις του Aho-Corasick ανήκει η συμβολοσειρά $x$, αυτό σημαίνει ότι στο κείμενο, μετά από το $x$ μπορεί να υπάρχει "κάτι άλλο". Αν υπάρχει η κενή συμβολοσειρά, αυτό το "κάτι άλλο" μπορεί να εμφανιστεί χωρίς μια σταθερή συμβολοσειρά πριν από αυτό, αλλά ο Aho-Corasick μπορεί βρει μόνο σταθερές συμβολοσειρές.

Για την αποφυγή υπερβολικού χρόνου εκτέλεσης ή χρήσης μνήμης, έχουν τεθεί κάποια αυθαίρετα όρια στον αλγόριθμο:

* Οι συμβολοσειρές του δέντρου δεν μπορούν να είναι μεγαλύτερες από __12__ χαρακτήρες.
* Το δέντρο δεν μπορεί να έχει περισσότερους από __128__ κόμβους (ή __256__ στις υλοποιήσεις με παραγόμενο κώδικα, μιας και έχουμε περισσότερο χρόνο στη διάθεσή μας).
* Σύνολα που αντιστοιχίζουν πάνω από __16__ χαρακτήρες ή που αντιστοιχίζουν όλους εκτός από ορισμένους (όπως τα `[a-z]` ή `[^ ]` αντίστοιχα) δεν υποστηρίζονται.

Αν η προσθήκη ενός κόμβου θα παραβιάσει κάποιο από τα όρια, ο κόμβος δεν προστίθεται και εφαρμόζεται η προηγούμενη περάγραφος περι "διακοπής" της ροής. Το ίδιο συμβαίνει αν ο αλγόριθμος συναντήσει δομές κανονικών εκφράσεων που δεν αντιστοιχούν σε σταθερές συμβολοσειρές, όπως backreferences. [Άλλες δομές που δεν προσθέτουν χαρακτήρες αγνοούνται.](https://github.com/teo-tsirpanis/dotnet-runtime/blob/752473231ee952db44223f698ddd2d2af5599aa7/src/libraries/System.Text.RegularExpressions/src/System/Text/RegularExpressions/TrieBuilder.cs#L448-L464)

Η υλοποίηση του αλγορίθμου βρίσκεται στο αρχείο [`TrieBuilder.cs`](https://github.com/teo-tsirpanis/dotnet-runtime/blob/752473231ee952db44223f698ddd2d2af5599aa7/src/libraries/System.Text.RegularExpressions/src/System/Text/RegularExpressions/TrieBuilder.cs). Η κλάση των κόμβων του δέντρου βρίσκεται στο αρχείο [`TrieNode.cs`](https://github.com/teo-tsirpanis/dotnet-runtime/blob/752473231ee952db44223f698ddd2d2af5599aa7/src/libraries/System.Text.RegularExpressions/src/System/Text/RegularExpressions/TrieNode.cs).

> Η κλάση `TrieNode` δεν περιέχει πεδία για τις τιμές που χρειάζεται ο Aho-Corasick, αυτές βρίσκονται στον τύπο `TrieNodeWithLinks` που βρίσκεται στο αρχείο `MultiStringMatcher.cs`.

### Επιλογή χρήσης του Aho-Corasick

Ο αλγόριθμος Aho-Corasick δεν είναι ασημένια σφαίρα, και δεν συμφέρει πάντα να χρησιμοποιήσουμε αυτόν έναντι κάποιας άλλης συντόμευσης. Το πρόβλημα του να αποφασίσουμε πότε θα τον χρησιμοποιήσουμε είναι το δυσκολότερο από τα τρία υποπροβλήματα της ενσωμάτωσης, επειδή δεν λύνεται _ακριβώς_ με αλγόριθμο αλλά _προσεγγιστικά_ με ευρετικούς κανόνες.

Θα ήταν πιο βολικό αν μπορούσαμε να τοποθετήσουμε την συντόμευση πολλαπλών εναρκτήριων συμβολοσειρών κάπου ανάμεσα στη σειρά προτίμησης των συντομεύσεων, αλλά δε μπορούμε να το κάνουμε, επειδή υπάρχει μια σύγκρουση με την συντόμευση της εναρκτήριας συμβολοσειράς, όπως φαίνεται σε μοτίβα όπως το $ab(cd|ef)$· αν βάζαμε τον Aho-Corasick μετά την εναρκτήρια συμβολοσειρά, δε θα είχαμε καν την ευκαιρία να τον χρησιμοποιήσουμε, οπότε χρειαζόμαστε πιο σύνθετους κανόνες.

Αυτοί είναι με τη σειρά οι κανόνες προτίμησης σνυτομεύσεων την στιγμή που γράφεται το κείμενο (αναμένεται να αλλάξουν στο μέλλον):

1. Όπως είπαμε πριν, αν μπορούμε να χρησιμοποιήσουμε anchors το κάνουμε και σταματάμε, είναι η απολύτως καλύτερη συντόμευση.
2.
    Διαλέγουμε μεταξύ των συντομεύσεων μίας και πολλαπλών εναρκτήριων συμβολοσειρών, ως εξής:
    1. Δεν προσπαθούμε καν να χρησιμοποιήσουμε τον Aho-Corasick και πάμε στο βήμα 2.4 αν:
        * Χρησιμοποιούμε την υλοποίηση χωρίς οπισθοδρόμηση (η ίδια η υλοποίηση κάνει κάτι παρόμοιο, ας μην το κάνουμε δυο φορές).
        * Χρησιμοποιούμε τη λειτουργία αντιστοίχισης από τα δεξιά προς τα αριστερά (για να την υποστηρίξουμε θα χρειαζόταν να αντιστρέψουμε όλες τις επαναλήψεις στην δημιουργία του δέντρου και στην αντιστοίχιση, και η λειτουργία δεν είναι αρκετά συνηθισμένη για να αξίζει τον κόπο).
    2. Προσπαθούμε να δημιουργήσουμε ένα δέντρο συμβολοσειρών από το μοτίβο μας. Για εξοικονόμηση υπολογισμών, στο δέντρο δεν προσθέσαμε ακόμα τις τιμές που χρειάζονται για τον Aho-Corasick. Αν δε μπορέσουμε να δημιουργήσουμε ένα δέντρο πάμε στο βήμα 3 (δεν προσπαθούμε καν να βρούμε εναρκτήρια συμβολοσειρά· για να μη μπορέσουμε να σχηματίσουμε ένα δέντρο δε θα υπάρχει) Υπάρχουν δύο πιθανοί λόγοι αποτυχίας:
        * Το δέντρο έχει μόνο έναν κόμβο -τη ρίζα-, που σημαίνει ότι δεν καταφέραμε να προσθέσουμε κανέναν άλλον.
        * Η ρίζα του δέντρου είναι κόμβος αντιστοίχισης, για τους λόγους που εξηγήσαμε στην προηγούμενη υποενότητα.
    3. Αποφασίζουμε αν το δέντρο είναι κατάλληλο για χρήση. Αν είναι, πάμε στο βήμα 3, αλλιώς συνεχίζουμε στο βήμα 2.4. Ένα δέντρο δεν είναι κατάλληλο αν:
        * Υπάρχει ένα μονοπάτι κόμβων με ένα παιδί που ξεκινάει από τη ρίζα και καταλήγει σε κάποιον κόμβο αντιστοίχισης, που σημαίνει ότι όλες οι συμβολοσειρές του δέντρου ξεκινάνε με το ίδιο πρόθημα το οποίο ανήκει στις λέξεις που θέλουμε να βρούμε.
        * Περιέχει λιγότερους από __2__ κόμβους αντιστοίχισης, ή __5__ στις υλοποιήσεις με παραγόμενο κώδικα. Το όριο αυτό προέκυψε από μετρήσεις απόδοσης (benchmarks)· οι μεταγλωττισμένες υλοποιήσεις χρειάζονται μεγαλύτερα δέντρα για να γίνουν γρήγορες, ενώ στις διερμηνευόμενες βλέπουμε βελτιώσεις και με το κατώτατο πλήθος των δύο (ένα δέντρο με έναν κόμβο αντιστοίχισης σημαίνει ότι έχουμε μόνο μία εναρκτήρια σταθερή συμβολοσειρά).
        * Όλοι οι κόμβοι του εκτός από τη ρίζα είναι κόμβοι αντιστοίχισης. Αυτό αποτρέπει μοτίβα όπως το $[0-9]$ από το να χρησιμοποιήσουν τον Aho-Corasick· το εναρκτήριο σύνολο είναι μια πολύ καλύτερη συντόμευση.
    4. Προσπαθούμε να βρούμε μια εναρκτήρια συμβολοσειρά στο μοτίβο μας.
3. Αν έχουμε βρει μια εναρκτήρια συμβολοσειρά, την χρησιμοποιούμε και σταματάμε.
4. Αν έχουμε βρει ένα δέντρο συμβολοσειρών, και μπορούμε να πραγματοποιήσουμε διανυσματοποιημένη αναζήτηση του εναρκτήριου χαρακτήρα (βλ. παρακάτω), δημιουργούμε ένα αντικείμενο `MultiStringMatcher` από το δέντρο -το οποίο κατά την κατασκευή θα θέσει τις τιμές για τον Aho-Corasick-, το χρησιμοποιούμε για τη συντόμευση πολλαπλών εναρκτήριων συμβολοσειρών, και σταματάμε.
5. Προσπαθούμε να βρούμε αν μπορούμε να χρησιμοποιήσουμε τις υπόλοιπες συντομεύσεις.
6. Αν δεν βρήκαμε μέχρι στιγμής κάποια συντόμευση, ή αυτή που βρήκαμε δεν είναι διανυσματοποιημένη, και είχαμε βρει προηγουμένως ένα δέντρο συμβολοσειρών, το χρησιμοποιούμε με τον τρόπο που περιγράφεται στο βήμα 4.

Ο κώδικας επιλογής της συντόμευσης βρίσκεται [στον δημιουργό της κλάσης `RegexFindOptimizations`](https://github.com/teo-tsirpanis/dotnet-runtime/blob/752473231ee952db44223f698ddd2d2af5599aa7/src/libraries/System.Text.RegularExpressions/src/System/Text/RegularExpressions/RegexFindOptimizations.cs#L18-L226). Το βήμα 2 υλοποιείται στην μέθοδο [`RegexPrefixAnalyzer.CreatePrefixMatcher`](https://github.com/teo-tsirpanis/dotnet-runtime/blob/752473231ee952db44223f698ddd2d2af5599aa7/src/libraries/System.Text.RegularExpressions/src/System/Text/RegularExpressions/RegexPrefixAnalyzer.cs#L14-L97).

<!-- TODO: prefix -> substring -->
