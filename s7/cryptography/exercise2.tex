\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{fontspec}
\usepackage{longtable}

\usepackage{listings}
\lstloadlanguages{Python}
\lstset{
    language=Python,
    basicstyle=\small\ttfamily,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    numbers=left,
    numbersep=5pt,
    keepspaces=true,
    showstringspaces=false,
    tabsize=2}

\setmainfont{Ubuntu}
\setmonofont{Ubuntu Mono}

\title{Κρυπτογραφία--Άσκηση 2: Επίθεση μόνο Κρυπτοκειμένου}
\author{Τσιρπάνης Θεόδωρος\\ \texttt{dai19090}}
\date{Οκτώβριος 2019}

\begin{document}

\maketitle

\section*{Ερώτημα 1}

Το πρώτο ερώτημα της άσκησης αφορά την μετατροπή του κώδικα του εργαστηρίου που υλοποιούσε τον ομοπαραλληλικό κρυπταλγόριθμο ώστε να χρησιμοποιεί τις δομές δακτυλίων στο $\mathbb{Z}_n$

Για να χρησιμοποιήσουμε τους δακτυλίους του SageMath στον ομοπαραλληλικό κρυπταλγόριθμο, αρκεί:

\begin{itemize}
\item στην συνάρτηση \lstinline|str2lst|, να μετατρέψουμε τους ακεραίους που αντιστοιχούν σε κάθε γράμμα του αλφαβήτου στον αντίστοιχό τους στο δακτύλιο $\mathbb{Z}_n$.

\item στην συνάρτηση \lstinline|lst2str|, να γυρίσουμε τους ακεραίους του $\mathbb{Z}_n$ πίσω στο $\mathbb{Z}$.

\item στις συναρτήσεις κρυπτογράφησης και αποκρυπτογράφησης, να αφαιρέσουμε τον τελεστή modulo.
\end{itemize}

Με τις παραπάνω αλλαγές, ο κώδικας θα έχει γίνει ως εξής:

\begin{lstlisting}
n = 26
Zn = IntegerModRing(n)

def str2lst(s):
    return [Zn(ord(x) - ord("A")) for x in s]

def lst2str(lst):
    return ''.join([chr(int(x) + ord("A")) for x in lst])

def affine_enc(m,k1,k2):
    plaintextList = str2lst(m)
    ciphertextList = [k1*x + k2 for x in plaintextList]
    ciphertext = lst2str(ciphertextList)
    return ciphertext

def affine_dec(c,k1,k2):
    k1_inverse=inverse_mod(k1, 26)
    ciphertextList = str2lst(c)
    plaintextList = [k1_inverse * (x-k2) for x in ciphertextList]
    plaintext = lst2str(plaintextList)
    return plaintext
\end{lstlisting}

Ένα άλλο πλεονέκτημα στην μετατροπή αυτή είναι ότι οι συναρτήσεις \lstinline|affine_enc| και \lstinline|affine_dec| λειτουργούν ανεξάρτητα από το $n$, το οποίο γνωρίζει μόνο η \lstinline|str2lst|.

\section*{Ερώτημα 2}

Το δεύτερο ερώτημα αφορά την μελέτη μίας \emph{Επίθεσης Γνωστού Απλού Κειμένου (Known Plaintext Attack)} στον ομοπαραλληλικό κρυπταλγόριθμο. Ας δούμε πρώτα όμως ένα μαθηματικό υπόβαθρο.

Για κάποιο $n \in \mathbb{Z}_+^*$, ο ομοπαραλληλικός κρυπταλγόριθμος συνδέει το απλό κείμενο $m \in \mathbb{Z}_n$ με το κρυπτοκείμενο $c \in \mathbb{Z}_n$ με την σχέση

$$c \equiv am + b \pmod n$$

Το ζεύγος $(a, b)$ αποτελεί το κλειδί. Οι αριθμοί αυτοί θα πρέπει να ανήκουν στον $\mathbb{Z}_n$, και επιπλέον το $a$ θα πρέπει να είναι σχετικά πρώτος με το $n$, αλλιώς ο πολλαπλασιασμός $am \pmod n$ δεν θα μπορούσε να αντιστραφεί στην αποκρυπτογράφηση.

Είναι προφανές ότι η παραπάνω σχέση είναι γραμμική, και καθώς το κλειδί αποτελείται από δύο άγνωστες μεταβλητές, θα πρέπει να έχουμε δύο διαφορετικά ζεύγη απλού κειμένου-κρυπτοκειμένου για να λύσουμε το σύστημα. Ας τα ονομάσουμε $(m_1, c_1)$ και $(m_2, c_2)$ -- με $m_1 \ne m_2$ (άρα και $c_1 \ne c_2$) --, και ας λύσουμε το γραμμικό σύστημα των σχέσεών τους:

\begin{equation} \label{crack_a}
\begin{split}
\begin{cases}
c_1 \equiv a m_1 + b \pmod n \\
c_2 \equiv a m_2 + b \pmod n
\end{cases} (-) &\Rightarrow \\
c_1 - c_2 \equiv a(m_1 - m_2) \pmod n &\Rightarrow \\
a \equiv (m_1 - m_2)^{-1} (c_1 - c_2) \pmod n
\end{split}
\end{equation}

Γνωρίζοντας το $a$, το $b$ υπολογίζεται πολύ εύκολα, αφού ισχύει:

\begin{align*}
c &\equiv am + b \pmod n \Rightarrow \\
\Rightarrow b &\equiv c - am \pmod n
\end{align*}

Για να υπολογιστεί το $(m_1 - m_2)^{-1} \pmod n$, θα πρέπει το $m_1 - m_2$ να είναι σχετικά πρώτος με το $n$. Σε μια \emph{Επίθεση Επιλεγμένου Απλού Κειμένου (Chosen Plaintext Attack)}, μπορούμε να επιλέξουμε τα δύο απλά κείμενα ώστε να πληρούν την παραπάνω ιδιότητα. Αν δεν μπορούμε να τα επιλέξουμε όμως, θα πρέπει να περιμένουμε να μας τύχουν δύο τέτοια.

Ας δούμε κι' ένα παράδειγμα. Με $n = 26$, έχουμε το απλό κείμενο $\texttt{WE} \equiv (23, 5)$, που κρυπτογραφείται σε $\texttt{MW} \equiv (13, 23)$. Αντικαθιστώντας τις τιμές στην (\ref{crack_a}), έχουμε:

\begin{align*}
a &\equiv (23 - 13)^{-1} (5 - 23) &\pmod{26} \\
  &\equiv 10^{-1} \cdot 8 &\pmod{26}
\end{align*}

Το πρόβλημα είναι ότι δεν υπάρχει το $10^{-1} \pmod{26}$, που σημαίνει ότι δεν μπορούμε να βρούμε το κλειδί μόνο με τις πληροφορίες που έχουμε. Θα πρέπει να αποκτήσουμε περισσότερα ζεύγη απλού κειμένου-κρυπτοκειμένου για να αυξήσουμε τις πιθανότητές μας να ταιριάζουν δύο από αυτά.

Προφανώς αυτή η συνθήκη θα ικανοποιούταν πάντοτε αν το $n$ ήταν πρώτος.

\section*{Ερώτημα 3}

Στο τρίτο ερώτημα, καλούμαστε να τροποποιήσουμε τον κώδικα του εργαστηρίου που επιτίθετο στον ομοπαραλληλικό κρυπταλγόριθμο ώστε να προσπαθεί να βρει μια δυάδα απλών κειμένων που ικανοποιούν την ιδιότητα που περιγράψαμε στο \emph{Ερώτημα 2}. Ο κώδικας θα μετατραπεί ως εξής:

\begin{lstlisting}
def find_suitable_plaintext_pair(plaintext):
    for i in range(len(plaintext) - 1):
        for j in xrange(i + 1, len(plaintext)):
            if gcd(plaintext[i] - plaintext[j], n) == 1:
                return (i, j)
    raise RuntimeError("Cannot crack the given plaintext-ciphertext pair. Please provide a bigger sample")

def affine_analysis(m,c):
    mList=str2lst(m)
    cList=str2lst(c)

    idx0, idx1 = find_suitable_plaintext_pair(mList)

    A = matrix(Z26, 2, 2, [mList[idx0], 1, mList[idx1], 1])
    b = vector(Z26, [cList[idx0], cList[idx1]])
    key=A.solve_right(b)
    return key
\end{lstlisting}

Ας μιλήσουμε για τον κώδικα. Την σταθερά \lstinline|n|, την ορίσαμε στο προηγούμενο τμήμα κώδικα, και μπορούμε να αλλάξουμε. Ομοίως ορίσαμε τις συναρτήσεις \lstinline|str2lst| και \lstinline|lst2str|. Η αφαίρεση στην γραμμή 4 δεν χρειάζεται τον τελεστή modulo να την περιβάλλει, χάρη στην \lstinline|str2lst| που έθεσε τους ακεραίους στο $\mathbb{Z}_n$. Η συνάρτηση \lstinline|find_suitable_plaintext_pair| δοκιμάζει όλους τους χαρακτήρες του απλού κειμένου μεταξύ τους μέχρι να βρει κάποιο ζευγάρι που ταιριάζει. Αν το βρει, το χρησιμοποιεί για να πραγματοποιήσει την επίθεση. Αν δεν το βρει, σημαίνει μια εξαίρεση ζητώντας ένα μεγαλύτερο δείγμα.

\section*{Ερώτημα 4}

Το τελευταίο ερώτημα της εργασίας μας δίνει έναν νέο κρυπταλγόριθμο, ο οποίος για κάποιο $n \in \mathbb{Z}_+^*$ συνδέει τον κάθε χαρακτήρα $m_i \in \mathbb{Z}_n$ \emph{που βρίσκεται στην θέση $i$} της συμβολοσειράς του απλού κειμένου (με τον πρώτο χαρακτήρα να βρίσκεται στην θέση 1), με τον χαρακτήρα $c_i \in \mathbb{Z}_n$ του κρυπτοκειμένου, με την εξής σχέση:

$$c_i \equiv ai + bm_i + c \pmod n$$

Ας τον ονομάσουμε \emph{Ευαίσθητο στη Θέση Ομοπαραλληλικό Κρυπταλγόιθμο (Position-Sensitive Affine Cipher)}. Η τριάδα $(a, b, c)$ είναι το κλειδί. Οι αριθμοί αυτοί θα πρέπει να ανήκουν στον $\mathbb{Z}_n$, και επιπλέον το $b$ θα πρέπει να είναι σχετικά πρώτος με το $n$, αλλιώς ο πολλαπλασιασμός $bm_i \pmod n$ δεν θα μπορούσε να αντιστραφεί στην αποκρυπτογράφηση. Ο κρυπταλγόριθμος αυτός μοιάζει πολύ με τον ομοπαραλληλικό κρυπταλγόριθμο που είδαμε πριν, με τον δεύτερο να αποτελεί μια ειδική περίπτωση του πρώτου, όταν $a = 0$.

Στα κλειδιά του κρυπταλγορίθμου μας, είπαμε ότι τα $a, c \in \mathbb{Z}_n$, που σημαίνει ότι το καθένα μπορεί να πάρει $n$ διαφορετικές τιμές. Είδαμε και ότι το $b$ πρέπει να είναι σχετικά πρώτος με το $n$, αφήνοντάς το να πάρει $\phi(n)$ διαφορετικές τιμές. Συνολικά, $\forall n \in \mathbb{Z}_+^*$, το μέγεθος του κλειδοχώρου είναι:

$$n \cdot \phi(n) \cdot n = n^2\phi(n)$$

Για $n = 26$, το μέγεθος του κλειδοχώρου είναι:

$$26^2\phi(26) = 8112$$

\subsection*{Ένα παράδειγμα}

Για να καταλάβουμε καλύτερα τον κρυπταλγόριθμο, ας κάνουμε ένα παράδειγμα. Έχουμε την αγγλική λέξη \texttt{VIPE} και το κλειδι $(3, 17, 8)$ με $n = 26$.

\begin{longtable}[c]{|p{7em}|l|l|l|l|}
\hline
$m_i$ & V$_1$ & I$_2$ & P$_3$ & E$_4$ \\
\hline
Μετατρέπουμε τους χαρακτήρες στον αντίστοιχο αριθμό τους στο $\mathbb{Z}_{26}$ & $21_1$ & $8_2$ & $15_3$ & $4_4$ \\
\hline
Βρίσκουμε το $c_i$ με την παραπάνω σχέση & $3 \cdot 1 + 17 \cdot 21 + 8$ & $3 \cdot 2 + 17 \cdot 8 + 8$ & $3 \cdot 3 + 17 \cdot 15 + 8$ & $3 \cdot 4 + 17 \cdot 4 + 8$ \\
\hline
Κάνουμε τις πράξεις & $368$ & $150$ & $272$ & $88$ \\
\hline
mod $26$ & $4$ & $20$ & $12$ & $10$ \\
\hline
Μετατρέπουμε τους χαρακτήρες στο αγγλικό αλφάβητο (το A είναι 0) & E & U & M & K \\
\hline
\end{longtable}

\subsection*{Η αποκρυπτογράφηση}

Για να αποκρυπτογραφήσουμε ένα κρυπτοκείμενο $m_i$ στην θέση $i$ με κλειδί $(a, b, c)$ και $n \in \mathbb{Z}_+^*$, παίρνουμε την σχέση απλού κειμένου-κρυπτοκειμένου και λύνουμε ως προς το κρυπτοκείμενο:

\begin{align*}
c_i &\equiv ai + bm_i + c &\pmod n &\Rightarrow \\
bm_i &\equiv c_i - ai - c &\pmod n &\Rightarrow \\
m_i &\equiv b^{-1}(c_i - ai - c) &\pmod n
\end{align*}

Ας δούμε ένα παράδειγμα. Έχουμε το απλό κείμενο \texttt{SMQ} με κλειδί την τριάδα $(5, 11, 2)$ και $n = 26$.

Πριν αρχίσουμε, θα πρέπει να υπολογίσουμε το $11^{-1} \pmod{26}$, που είναι το $19$, μιας και $11 \cdot 19 = 209 = 26 \cdot 8 + 1$. Και τώρα μπορούμε να ξεκινήσουμε:

\begin{longtable}[c]{|p{7em}|l|l|l|}
\hline
$m_i$ & S$_1$ & M$_2$ & Q$_3$ \\
\hline
Μετατρέπουμε τους χαρακτήρες στον αντίστοιχο αριθμό τους στο $\mathbb{Z}_{26}$ & $18_1$ & $12_2$ & $16_3$ \\
\hline
Βρίσκουμε το $m_i$ με την παραπάνω σχέση & $19(18 - 5 \cdot 1 - 2)$ & $19(12 - 5 \cdot 2 - 2)$ & $19(16 - 5 \cdot 3 - 2)$ \\
\hline
Κάνουμε τις πράξεις & $209$ & $0$ & $-19$ \\
\hline
mod $26$ & $1$ & $0$ & $7$ \\
\hline
Μετατρέπουμε τους χαρακτήρες στο αγγλικό αλφάβητο (το A είναι 0) & B & A & H \\
\hline
\end{longtable}

\end{document}
