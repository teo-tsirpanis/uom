# Τεχνητή Νοημοσύνη - Εργασία 1

### Τσιρπάνης Θεόδωρος - `dai19090`

## Περιγραφή του προγράμματος

Για την εργασία ζητήθηκε η συγγραφή ενός προγράμματος που θα λύνει παιχνίδια Peg Solitaire με τους αλγορίθμους αναζήτησης "πρώτα σε βάθος" και "πρώτα στο καλύτερο". Το πρόγραμμα είναι γραμμένο στην αντικειμενοστρεφή γλώσσα προγραμματισμού C# και εκτελείται στην πλατφόρμα .NET. Η αρχιτεκτονική του είναι εμπνευσμένη από το συναρτησιακό προγραμματιστικό υπόδειγμα, χρησιμοποιώντας αμετάβλητους (immutable) τύπους δεδομένων και και διαχειρίζοντας με ευκολία τις πολλές διαφορετικές καταστάσεις του παιχνιδιού.

Το επιβεβλημένο από την εκφώνηση timeout υλοποιείται με το καθιερωμένο μηχανισμό ακύρωσης του .NET. Με τη βοήθεια του τύπου `CancellationToken`, σε κάθε επανάληψη του αλγορίθμου αναζήτησης, ελέγχεται αν έχει ζητηθεί ακύρωση (είτε με timeout είτε πατώντας <kbd>Ctrl</kbd>+<kbd>C</kbd> στην γραμμή εντολών), και αναλόγως η αναζήτηση σταματάει ή συνεχίζεται.

Στο τέλος της αναζήτησης, επιτυχημένης ή μη, το πρόγραμμα εμφανίζει το πλήθος των καταστάσεων που εξέτασε, καθώς και την διάρκεια αναζήτησης.

Επίσης η αναζήτηση μπορεί να συνεχιστεί από συγκεκριμένο σημείο, είτε για να συνεχιστεί μετά από ακύρωση είτε για να βρεθούν πάνω από μία λύσεις, αλλά αυτή η δυνατότητα δεν χρησιμοποιείται.

### Οδηγίες εκτέλεσης

Για την εκτέλεση του προγράμματος απαιτείται η εγκατάσταση του πακέτου ανάπτυξης λογισμικού του .NET 5 που μπορεί να ληφθεί από το https://dotnet.microsoft.com/download.

Στη συνέχεια το πρόγραμμα μπορεί να μεταγλωττιστεί και να εκτελεστεί ανοίγοντας μια γραμμή εντολών και χρησιμοποιώντας το αρχείο `run.bat` ως εξής:

```
run.bat dfs examples/6x6.txt 6x6.out.txt

run.bat best examples/6x6.txt 6x6.out.txt

run.bat verify examples/6x6.txt 6x6.out.txt
```

Οι εντολές `dfs` και `best` χρησιμοποιούν αντίστοιχα για ευρετική συνάρτηση μια τυχαία γεννήτρια τυχαίων αριθμών (για να αποφευχθεί μεροληψία προς την πρώτη διαθέσιμη κίνηση· καθώς δεν κάνει πληροφορημένη την αναζήτηση παραμένει πρώτα κατά βάθος), και την μέση απόσταση Manhattan μεταξύ των πλακιδίων.

Η εντολή `verify` "παίζει" ένα παιχνίδι, εμφανίζει την τελική κατάστασή του και αν είναι νικηφόρα ή όχι.

Το πρόγραμμα τερματίζει με κωδικό εξόδου 0 αν βρήκε λύση στο παιχνίδι ή αν το παιχνίδι που έπαιξε κατέληξε σε νίκη, 1 αν υπήρξε κάποιο σφάλμα στην είσοδο και 2 αν δε μπόρεσε να βρει λύση στο παιχνίδι ή αν το παιχνίδι που έπαιξε κατέληξε σε ήττα.

Η αναζήτηση τερματίζει αν δεν βρει νικηφόρα κατάσταση μετά από 15 λεπτά. Το timeout αυτό μπορεί να απενεργοποιηθεί θέτοντας τη μεταβλητή περιβάλλοντος `PEG_SOLITAIRE_DISABLE_TIMEOUT` στον αριθμό 1.

### Παρατηρήσεις επί του κώδικα

Ο κώδικας χρησιμοποιεί αρκετές ιδιωματικές δυνατότητες της C#, από τις οποίες κάποιες θα εξηγηθούν για την ευκολότερη κατανόησή του:

* Μετά το όνομα του τύπου εμφανίζεται σε ορισμένες περιπτώσεις ένα αγγλικό ερωτηματικό, που σημαίνει ότι αυτή η μεταβλητή ή αυτό το πεδίο μπορεί να πάρει την τιμή `null`· σε όλες τις άλλες περιπτώσεις _δεν_ μπορεί να πάρει. Αυτό επιτρέπει τον μεταγλωττιστή να σιγουρευτεί ότι γίνονται έλεγχοι για την τιμή `null` εκεί που πρέπει, και να σημάνει προειδοποιήσεις αν δε γίνεται.

* Στις δηλώσεις παραμέτρων ορισμένων μεθόδων, χρησιμοποιείται το προσδιοριστικό `in`, που σημαίνει ότι η παράμετρος μεταφέρεται στη μέθοδο με αναφορά χωρίς όμως να μπορεί να τροποποιηθεί. Επειδή κάποιοι τύποι δεν είναι κλάσεις αλλά δομές (structs), χρησιμοποιείται αυτό το προσδιοριστικό για εξοικονόμηση μεταφορών δεδομένων από και προς την στοίβα.

* Δεν υπάρχει ακριβώς μέθοδος `Main`. Το σημείο εισόδου είναι στο αρχείο `Program.cs` και αποτελείται από όλες τις εντολές του χωρίς να βρίσκονται ρητά σε κάποια μέθοδο.

## Υπολογιστική μελέτη

Στην υπολογιστική μελέτη θα χρησιμοποιηθούν τρία ταμπλό από αυτά στον φάκελο `examples`, το `english.txt`, το κλασσικό ταμπλό που συναντάται στο παράδειγμα 4 της εκφώνησης, το `simple.txt` που συναντάται στη σελίδα 2 της εκφώνησης και το `6x6.txt`, ένα κατακόρυφα συμμετρικό ταμπλό διαστάσεων 6×6 με 22 κομμάτια.

Τα αποτελέσματα εμφανίζονται στον παρακάτω πίνακα:

|Ταμπλό|Αλγόριθμος αναζήτησης|Καταστάσεις που εξετάστηκαν|Διάρκεια αναζήτησης (HH:MM:SS.mS)|
|------|---------------------|---------------------------|----------------------------------------|
|`simple.txt`|`dfs`|17|00:00:00.0115959|
|`simple.txt`|`dfs`|21|00:00:00.0108592|
|`simple.txt`|`best`|17|00:00:00.0137762|
|`6x6.txt`|`dfs`|73264|00:00:00.2036834|
|`6x6.txt`|`dfs`|800|00:00:00.0138289|
|`6x6.txt`|`best`|15387|00:00:00.0690373|
|`english.txt`|`best`|441745268|00:15:00.0187411 __(timeout)__|

Δυστυχώς το πρόγραμμα δε κατάφερε να βρει λύση σε μεγάλα ταμπλό όπως το `english.txt`, τερματίζοντας με αποτυχία μετά από δεκαπέντε λεπτά, έχοντας εξετάσει περίπου είκοσι εννιά και μισό εκατομμύρια καταστάσεις το λεπτό.

Επειδή η αναζήτηση πρώτα σε βάθος γίνεται μη ντετερμινιστικά, παρουσιάζονται τα αποτελέσματα δύο εκτελέσεών της. Η αναζήτηση πρώτα στο καλύτερο δεν αντιμετωπίζει το πρόβλημα αυτό.

### Συμπεράσματα

Η δεύτερη από τις δύο αναζητήσεις πρώτα σε βάθος του `6x6.txt` έτυχε να είναι με διαφορά συντομότερη από την πρώτη, αναδεικνύοντας την απρόβλεπτη φύση της αναζήτησης όπως έχει υλοποιηθεί. Επίσης, λαμβάνοντας υπόψη ότι ο υπολογισμός της ευρετικής συνάρτησης έχει πολυπλοκότητα O(N<sup>4</sup>) και κατά συνέπεια καταλαμβάνει ένα μη αμελητέο ποσοστό του χρόνου εκτέλεσης της αναζήτησης (το ένα τέταρτο περίπου, όπως φάνηκε σε μια εκτέλεση με τη βοήθεια profiler), το συμπέρασμα ότι η αναζήτηση πρώτα στο καλύτερο είναι πάντα προτιμότερη θα ήταν βιαστικό. Περαιτέρω υπολογιστικές μελέτες θα μπορούσαν να συγκρίνουν πολλές ευρετικές συναρτήσεις.
