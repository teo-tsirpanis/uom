# Λογικός Προγραμματισμός με Περιορισμούς - Εργασία 1

### Τσιρπάνης Θεόδωρος, `dai19090`

## Άσκηση 1

```prolog
% Exercise 1 code here
```

### Παραδείγματα εκτέλεσης

```
?- extend([(0, a), (0, b), (0, c)], Result).
Result = []
Yes (0.00s cpu, solution 1, maybe more)
No (0.00s cpu)

?- extend([(1, a), (2, b), (0, a), (2, c)], Result).
Result = [[a], [b, b], [c, c]]
Yes (0.00s cpu, solution 1, maybe more)
No (0.00s cpu)

?- extend([(-1, a)], Result).
No (0.00s cpu)
```

### Παρατηρήσεις

Χρησιμοποιήθηκαν δύο κατηγορήματα: το `extend` και το `list_replicate`, ένα βοηθητικό κατηγόρημα που επαναλαμβάνει ένα στοιχείο σε μια λίστα για έναν συγκεκριμένο αριθμό φορών. Το κατηγόρημα `extend` κάνει στην ουσία μια αντιστοίχιση (mapping) στα στοιχεία της λίστας εισόδου χρησιμοποιώντας το κατηγόρημα `list_replicate`, με μια ειδική περίπτωση για τα ζευγάρια που το πρώτο τους στοιχείο είναι το μηδέν, ώστε να παραλείπονται πλήρως και να μην αντιστοιχίζονται σε μια κενή λίστα.

## Άσκηση 2

```prolog
% Exercise 2 code here
```

### Παραδείγματα εκτέλεσης

```
?- find_flight(skg, edi, Plan, Cost, ETA).
Plan = [oa123, aa120, bt110]
Cost = 270
ETA = 23
Yes (0.00s cpu, solution 1, maybe more)
Plan = [oa123, bt190, bt110]
Cost = 240
ETA = 23
Yes (0.00s cpu, solution 2, maybe more)
Plan = [oa123, lf200, lf210]
Cost = 870
ETA = 22
Yes (0.00s cpu, solution 3, maybe more)
Plan = [oa124, aa120, bt110]
Cost = 230
ETA = 23
Yes (0.00s cpu, solution 4, maybe more)
Plan = [oa124, bt190, bt110]
Cost = 200
ETA = 23
Yes (0.00s cpu, solution 5, maybe more)
Plan = [oa124, lf200, lf210]
Cost = 830
ETA = 22
Yes (0.00s cpu, solution 6, maybe more)
Plan = [oa125, aa120, bt110]
Cost = 190
ETA = 23
Yes (0.00s cpu, solution 7, maybe more)
Plan = [oa125, bt190, bt110]
Cost = 160
ETA = 23
Yes (0.00s cpu, solution 8, maybe more)
Plan = [oa125, lf200, lf210]
Cost = 790
ETA = 22
Yes (0.00s cpu, solution 9, maybe more)
No (0.00s cpu)

?- find_flight(edi, skg, Plan, Cost, ETA).
No (0.00s cpu)

?- find_flight(edi, edi, Plan, Cost, ETA).
Plan = []
Cost = 0
ETA = 0
Yes (0.00s cpu, solution 1, maybe more)
No (0.00s cpu)
```

```
?- waiting_time([oa123, bt190, bt110], Result).
Result = 7
Yes (0.00s cpu, solution 1, maybe more)
No (0.00s cpu)

?- waiting_time([oa123], Result).
Result = 0
Yes (0.00s cpu, solution 1, maybe more)
No (0.00s cpu)

?- waiting_time([], Result).
Result = 0
Yes (0.00s cpu)
```

```
?- select_flight(skg, fra, Plan, 24, Cost, MinWait).
Plan = [oa125, lf200]
Cost = 590
MinWait = 1
Yes (0.00s cpu, solution 1, maybe more)
No (0.00s cpu)

?- select_flight(ath, fra, Plan, 24, Cost, MinWait).
Plan = [lf200]
Cost = 550
MinWait = 0
Yes (0.00s cpu, solution 1, maybe more)
No (0.00s cpu)
```

### Παρατηρήσεις

* Το κατηγόρημα `find_flight` εκτελεί μια αναζήτηση πρώτα σε βάθος στον γράφο με κόμβους τα αεροδρόμια και ακμές τις πτήσεις. Κατά την αναζήτηση διατηρούνται τα επισκεφθέντα αεροδρόμια για να μην προσπελαστούν ξανά, και οι πτήσεις που χρησιμοποιήθηκαν για να "επιστραφούν" στο τέλος μετά την αναστροφή της λίστας τους που θα βάλει την πρώτη πτήση στην αρχή. Επίσης ελέγχεται αν η ώρα αναχώρησης μιας πτήσης είναι μετά την ώρα άφιξης της προηγούμενης.

* Το κατηγόρημα `waiting_time` χρησιμοποιεί ένα βοηθητικό κατηγόρημα για να πραγματοποιήσει μια tail-recursive διάσχιση της λίστας των πτήσεων, προσθέτοντας σε κάθε βήμα σε έναν συσσωρευτή τον χρόνο αναμονής μεταξύ δύο συνεχόμενων πτήσεων στη λίστα, και σταματώντας όταν μένει μόνο μία ή καμία πτήση. Επίσης χρησιμοποιήθηκε μια φορά ο τελεστής της ρητής ενοποίησης για την αποφυγή επανάληψης κώδικα.

* Το κατηγόρημα `select_flight` χρησιμοποιεί τα δύο προηγούμενα, συλλέγοντας τις λύσεις του `find_flight`, ελέγχοντάς τες μία-μία αν η ώρα άφιξής τους είναι πριν την επιθυμητή και αν ο χρόνος αναμονής τους που υπολογίστηκε με το `waiting_time` είναι ο μικρότερος από όλες τις διαδρομές. Κατόπιν διευκρίνησης, αν πολλές διαδρομές έχουν τον ίδιο χρόνο αναμονής, το κατηγόρημα θα επιστρέφει μόνο μία.

## Άσκηση 3

```prolog
% Exercise 3 code here
```

### Παραδείγματα Εκτέλεσης

```
?- reduction([111, 555, *], Result).
Result = 61605
Yes (0.00s cpu, solution 1, maybe more)
No (0.00s cpu)

?- reduction([59, 475], Result).
No (0.00s cpu)
```

### Παρατηρήσεις

Η εκφώνηση προτίμησε μια υλοποίηση που δεν χρησιμοποιεί στοίβα. Η υλοποίηση αυτή απαιτεί τα σύμβολα να είναι σε Πολωνική γραφή (με τους τελεστές _πριν_ τους αριθμούς), οπότε η λίστα εισόδου αντιστρέφεται στην αρχή του κατηγορήματος `reduction`.

Η λογική βρίσκεται στο κατηγόρημα `extract_number`. Αποτελείται από μια λίστα με σύμβολα, τον πρώτο (αποτιμημένο έστω) ακέραιο αριθμό αυτής της λίστας, και τα υπόλοιπα σύμβολα της λίστας που βρίσκονται μετά τον ακέραιο.

Αν το πρώτο στοιχείο της λίστας είναι ακέραιος, τα άλλα δύο ορίσματα του κατηγορήματος θα έχουν απλά τον αριθμό αυτόν, και τα υπόλοιπα στοιχεία της λίστας αντίστοιχα.

Αν το πρώτο στοιχείο της λίστας είναι μοναδιαίος τελεστής, καλείται αναδρομικά το `extract_number` στα υπόλοιπα στοιχεία, αποτιμάται ο τελεστής με το ακέραιο αποτέλεσμα της αναδρομικής κλήσης, και το αποτέλεσμα του τελεστή ενοποιείται με το δεύτερο όρισμα του αρχικού `extract_number`. Τα υπόλοιπα στοιχεία του αρχικού `extract_number` ενοποιούνται με τα υπόλοιπα στοιχεία της αναδρομικής κλήσης.

Αν το πρώτο στοιχείο της λίστας είναι δυαδικός τελεστής, καλείται αναδρομικά το `extract_number` δυο φορές· την πρώτη με πρώτο όρισμα τα υπόλοιπα στοιχεία μετά τον τελεστή, και την δεύτερη με πρώτο όρισμα τα υπόλοιπα στοιχεία της πρώτης κλήσης του `extract_number`. Ο δυαδικός τελεστής αποτιμάται με τα αποτελέσματα των δύο αναδρομικών κλήσεων, το αποτέλεσμά του ενοποιείται με το δεύτερο όρισμα του αρχικού `extract_number`, ενώ το τρίτο όρισμά του ενοποιείται με αυτό της δεύτερης αναδρομικής κλήσης.

Το κατηγόρημα `extract_number` αποτυχαίνει όταν το πρώτο όρισμά του είναι η κενή λίστα, αποκλείοντας κενές ή άκυρες ακολουθίες εκφράσεων στο κατηγόρημα `reduction`. Επιπλέον, στην πρώτη κλήση του `extract_numbers`, το τρίτο όρισμά του ενοποιείται με την κενή λίστα, αποκλείοντας περιπτώσεις όπου δίνονται πολλοί αριθμοί χωρίς αρκετούς τελεστές, όπως το δεύτερο παράδειγμα.

Οι τελεστές δηλώνονται και αποτιμώνται με δύο κατηγορήματα· οι μοναδιαίοι με τα `is_unary_op` και `eval_unary_op`, και οι δυαδικοί με τα `is_binary_op` και `eval_binary_op`. Χρησιμοποιούνται δύο κατηγορήματα για να μπορεί το πρόγραμμα να ξέρει με το που βλέπει έναν τελεστή πόσα ορίσματα δέχεται και να μην κάνει οπισθοδρόμηση αν μαντέψει λάθος. Ο μηχανισμός αυτός επίσης προσφέρει επεκτασιμότητα, επιτρέποντας εύκολα την προσθήκη υποστήριξης επιπλέον τελεστών.
