\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{booktabs}

\usepackage{hyperref}
\usepackage{fontspec}
\usepackage{longtable}
\usepackage[greek,english]{babel}

\setmainfont{Ubuntu}
\setmonofont{Ubuntu Mono}

\title{Θεωρία Υπολογισμών και Αυτομάτων\\ Άσκηση 1}
\author{Τσιρπάνης Θεόδωρος\\ \texttt{dai19090}}
\date{Δεκέμβριος 2019}

\begin{document}

\selectlanguage{greek}

\maketitle

\section{Προσομοίωση πεπερασμένου αυτομάτου}

Το ζητούμενο της άσκησης είναι η ανάπτυξη ενός προγράμματος που θα προσομοιώνει ένα μη ντετερμινιστικό πεπερασμένο αυτόματο με ε-μεταβάσεις\footnote{Τα ντετερμινιστικά αυτόματα, καθώς και τα μη ντετερμινιστικά που δεν έχουν ε-μεταβάσεις αποτελούν ειδικές περιπτώσεις αυτών με ε-μεταβάσεις.} με διάφορες συμβολοσειρές εισόδου.

Ο πιο απλοϊκός τρόπος είναι μια διακλάδωση σε κάθε μη ντετερμινιστική μετάβαση. Με άλλα λόγια, αν από μια κατάσταση, οι επόμενες είναι οι $q_1$ και $q_2$, θα εξεταστούν \emph{ξεχωριστά} η κάθε μία. Το πρόβλημα είναι ότι στη χειρότερη περίπτωση, ο χρόνος εκτέλεσης θα είναι $\mathcal{O}(2^n)$ ως προς το μήκος της εισόδου.

Ευτυχώς, γνωρίζουμε ότι όλα τα πεπερασμένα αυτόματα μπορούν να μετατραπούν σε ντετερμινιστικά. Η μετατροπή αυτή θα γίνει μόνο μια φορά ανά αυτόματο, και μετά, η κάθε λέξη θα προσομοιώνεται σε χρόνο $\mathcal{O}(n)$. Ούτε κι' αυτή η προσέγγιση είναι η βέλτιστη. Στη χειρότερη περίπτωση, αν ένα μη ντετερμινιστικό αυτόματο έχει $r$ καταστάσεις, το αντίστοιχο ντετερμινιστικό θα έχει $2^r$ καταστάσεις. Οπότε, αυτή η προσέγγιση απαιτεί εκθετική \emph{μνήμη}, όχι χρόνο.

Υπάρχει όμως ένας άλλος τρόπος που περιγράφεται στο κεφάλαιο 3.7.2 του βιβλίου \textit{Μεταγλωττιστές} των Aho, Lam, Sethi και Ullman. Ο αλγόριθμος αυτός, δοθέντος ενός μη ντετερμινιστικού αυτομάτου $(Q, \Sigma, \delta, q_0, F)$, ουσιαστικά προσομοιώνει ένα \emph{ντετερμινιστικό} αυτόματο $(Q', \Sigma, \delta', \{q_0\}, F')$, όπου $Q' = 2^Q$, $\delta'(q_\text{current}, c) = \{q \in Q' : \exists x \in q_\text{current} : \exists y \in \text{ε-CLOSURE}(x) \land q \in \delta(y, c)\}$ και $F' = \{q \in Q' : \exists x \in q : x \in F\}$. Με άλλα λόγια, ο αλγόριθμος θυμάται κάθε φορά \emph{το σύνολο} των καταστάσεων όπου βρίσκεται, και για κάθε σύμβολο που διαβάζει, παίρνει το ε-κλείσιμο της κάθε κατάστασης στην οποία βρίσκεται, και για κάθε μία από αυτές τις καταστάσεις, προσθέτει το αποτέλεσμα της συνάρτησης μετάβασης στο σύνολο των επόμενων καταστάσεων. Όταν τελειώσει η είσοδος, το αυτόματο αποδέχεται τη λέξη αν και μόνο αν στο σύνολο των καταστάσεών του υπάρχει έστω και μία κατάσταση αποδοχής. Επειδή δεν οπισθοδρομούμε, ο αλγόριθμος διατηρεί έναν γραμμικό χρόνο ως προς το μήκος της εισόδου, με μια επιβάρυνση που εξαρτάται γραμμικά από το πλήθος των καταστάσεων.

\section{Η υλοποίηση του προγράμματος}

Το πρόγραμμα γράφτηκε στην \href{https://fsharp.org}{συναρτησιακή γλώσσα προγραμματισμού F\#}. Υπάρχουν δύο τρόποι να εκτελεστεί.

\begin{itemize}
    \item Το πρόγραμμα μπορεί να μεταγλαττιστεί και να εκτελεστεί τοπικά. Για να γίνει αυτό, χρειάζεται η έκδοση 3.1 του \href{https://dotnet.microsoft.com/download}{.NET Core SDK}. Είναι διαθέσιμο για Windows, macOS και Linux. Αφού εγκατασταθεί, το πρόγραμμα μπορεί να εκτελεστεί ανοίγοντας μια γραμμή εντολών στον κατάλογο όπου βρίσκεται ο πηγαίος κώδικας, και εκτελώντας την εντολή \texttt{dotnet run}.
    \item Για όσους προτιμούν να μην εγκαταστήσουν το SDK, μπορούν να χρησιμοποιήσουν μια διαδικτυακή υπηρεσία όπως το \href{https://repl.it/languages/fsharp}{repl.it}.
\end{itemize}

Το πρόγραμμα διαβάζει το αυτόματο από την κονσόλα, με μια μορφή που μοιάζει με αυτήν που περιγράφεται στην εκφώνηση, μόνο που αγνοεί το πλήθος των καταστάσεων αποδοχής (αφού διαβάζονται όλες με τη μία), και χρησιμοποιεί τον συμβολισμό \texttt{X Y} για να δηλώσει μια ε-μετάβαση από την κατάσταση X στην Y. Οι καταστάσεις απαριθμούνται με βάση το 1. Το πρόγραμμα τερματίζει με σφάλμα αν διαβάσει άκυρη είσοδο. Όταν διαβαστεί η τελευταία μετάβαση, το πρόγραμμα διαβάζει γραμμές από την κονσόλα και τις προσομοιώνει στο αυτόματο μέχρι να κλείσει το πρόγραμμα ο χρήστης.

Παρατίθενται μαζί με τον πηγαίο κώδικα του προγράμματος οι περιγραφές τριών αυτομάτων που πάρθηκαν από τις ασκήσεις του μαθήματος, μαζί με ενδεδειγμένες εισόδους, κάποιες εκ των οποίων αναγωρίζονται από το αυτόματο. Για να ελεγχθεί η ορθότητα του προγράμματος, παρατίθενται και τα αναμενόμενα αρχεία εξόδου.

Το πρόγραμμα γράφτηκε για να δουλεύει με τις δυνατότητες διασωλήνωσης που έχουν ορισμένα κέλυφη. Γι' αυτόν τον λόγο, οι παραπάνω δοκιμές μπορούν να γίνουν εκπληκτικά εύκολα, εκτελώντας μια εντολή του τύπου \texttt{cat example1.in.txt | dotnet run}, η οποία δουλεύει και στο Windows PowerShell.

Το πρόγραμμα υλοποιεί τον αλγόριθμο που περιγράφτηκε στην προηγούμενη ενότητα. Στο κεφάλαιο 3.7.3 του βιβλίου \textit{Μεταγλωττιστές}, υπάρχουν κάποιες ακόμα προτάσεις για βελτιστοποίηση που, δεν υλοποιήθηκαν γιατί θα αυξανόταν η πολυπλοκότητα του πηγαίου κώδικα, και η απόδοση του προγράμματος δεν είναι τόσο κρίσιμη. Παρ' όλα αυτά, το αποτέλεσμα της συνάρτησης μετάβασης για κάποιο σύνολο καταστάσεων και σύμβολο, απομνημονεύεται από το πρόγραμμα όταν υπολογιστεί την πρώτη φορά, αποφεύγοντας περιττούς υπολογισμούς.

\end{document}
